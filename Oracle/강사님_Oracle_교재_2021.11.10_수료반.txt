Port for 'Oracle Database Listener': 1521
운영체제가 부여하는 포트번호 1521

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<1> 데이터베이스란?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
[검색]이 용이하도록 일정한 기준에 맞추어 자료를 분류하여 정리해 놓은 [자료의 집합]을 말한다.
●데이터베이스 조건(입, 기)
	실시간 접근성, 지속적인 변화(=최신의 정보가 가장 정확하게 저장), 동시 공유 등

데이터베이스가 가장 싫어하는 것 정확성과 일관성을 잃어버리는것


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<2> RDBMS (Relation Database Management System, 관계형 데이터베이스 관리 시스템) 이란? (입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●데이터가 [컬럼(column) = 열]과 [로우(Row) = 행]로 이루어진 [테이블]에 저장되며, [테이블]들 사이에 관계를
설정하여 관리하는 SW 또는 시스템을 말한다.
●RDBMS 제품의 종류
	Oracle사의 Oracle ( = 대기업, 공기업 프로젝트에 지배적으로 사용됨. 라이센스 비용이 증가하는 추세)
	MS 사의 MS-SQL  ( = 대기업용)
	Sun Microsystems 사의 MYSQL ( = 중소기업용)
	Sybase
	DB2 등
●고객의 정보를 저장하는 테이블 custumer가 있다면 아래와 같은 구조로 데이터를 저장하여 관리한다.
-----------------------------------------------------------------------

		custumer			  => 테이블명
----------------------------------------------------
고객번호       고객명       주소        전화번호     => column명
----------------------------------------------------
     1	      저팔계       서울     02-1234-1234 => row(행)
----------------------------------------------------
     2	      사오정       부산     02-2345-2345 => row(행)
----------------------------------------------------
     3	      손오공       제주     02-3456-3456 => row(행)
----------------------------------------------------
   column      column     column       column
     (열)           (열)          (열)            (열)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<3> SQL(Structured Query Language)란?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●RDBMS에 접근해서 데이터의 [입력], [수정], [삭제], [검색] 하는 등의 기능을 가진 RDBMS 관리 언어이다.
 <참고> DB, 즉 오라클을 배운다라는 말은 SQL 언어를 배우는 것과 동일하다.

○데이터베이스 사용자와 관계형 데이터베이스를 연결시켜주는 표준 검색 언어. 이미 구조화된 질의 언어라는 뜻으로써, 일정한 질의 언어로 DB를 제어할 수 있으므로, 데이터를 매우 쉽게 관리할 수 있다.

○Query => 데이터베이스에 질문하는 것으로써, 데이터 자체의 변경은 하지 않고 속성 데이터를 조사하는 것. 논리연산 등을 이용하여 조건 검색을 행하며, 주로 관계형 데이터베이스에 의해 구축된 속성 데이터 중에서 조건에 맞는 것을 선택한다.


●특징
	▶[절차적 언어]가 아닌 [구조적 언어]이다.
	   <참고>절차적(procedural) 언어 (입)
		▷모든 처리 과정을 일일이 기술하고 기술된 순서대로 로직이 처리되는 언어. (C, Java 등)
	   <참고>구조적(structured) 언어 (입)
		▷처리 과정을 일일이 기술할 필요 없이 일정한 틀이나 패턴이 있어 맞게 조건들만
                        나열하면 로직이 처리되는 언어.

●SQL 종류(기, 입)
	--------------------------------------------------------
	DDL(Data Definition Language = 데이터 정의 언어)
	--------------------------------------------------------
		▶객체를 생성, 수정, 삭제 등의 작업을 한다.
		-----------------------
		CREATE => 객체 생성
		ALTER => 객체 수정 <조심> update가 아니다. 시험문제에 자주 등장
		DROP => 객체 삭제
		기타 등등
		-----------------------
		<주의>오라클에서 객체란 이름을 가지고 저장되는 놈들을 객체라 부른다. 자바의 객체와 다르다.
		<참고>오라클에서 객체는 [테이블], [뷰], [트리거], [인덱스], [프로시저], [시퀀스] 등을 말한다.

	--------------------------------------------------------
	DML(Date Manipulation Language = 데이터 처리 언어)
	--------------------------------------------------------
		▶테이블 안의 데이터를 입력, 수정, 삭제, 검색 등의 작업을 한다. (데이터는 객체가 아님)
		DDL은 간단해서 어렵지 않지만, SELECT가 비중이 큼
		-----------------------------------------
		INTSERT => 행 단위의 데이터 입력
		UPDATE => 셀 단위의 데이터 수정/삭제
		DELETE => 행 단위의 데이터 삭제
		SELECT => n행 m열의 데이터 검색(SQL 공부 8-90% 이상의 비중을 차지함)
		["DB 실력은 SELECT 구사 능력이다."]
		-----------------------------------------
		<문제> 셀에 들어있는 데이터를 제거하는 SQL 구문은? UPDATE.
			학원 프로젝트에 주도적으로 참여했는지 여부 확인할 수 있는 질문
		<문제> 행을 제거하는 SQL 구문은? DELETE

		[행 단위] - INSERT(입력), DELETE(삭제)
		[셀 단위] - UPDATE(수정,삭제)


	--------------------------------------------------------
	DCL(Data Control Language = 데이터 제어 언어)
	--------------------------------------------------------
		COMMIT	  => 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 인정
			작업을 인정한다는 뜻은 원래대로 돌려놓을 수 없다.
		ROLLBACK => 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 취소

		GRANT     => 접근제어, 작업권한허용
		REVOKE     => 권한 제거


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<4> 트랜잭션(Transaction)이란? (기, 입, 실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●모두 취소되거나 모두 완료되는 2가지 결론으로만 진행되는 작업단위(모 아니면 도)
●트랜잭션은 주로 입력, 수정, 삭제 SQL구문 실행 시 설정한다.
●트랜잭션이 없으면 데이터가 누락될 수 있다.
●트랜잭션이 걸린 작업은 가상 작업이 되고 ROLLBACK을 실행하면 모두 취소되고, COMMIT을 실행하면
가상작업이 모두 실제 작업으로 인정된다.
●SELECT 데이터에 영향을 주지않는 검색작업이므로 트랜잭션의 대상이 되지 않는다.
●<주의>트랜잭션은 의도를 가지고 설정하는 것이다.
●<주의>트랜잭션이 없는 작업은 N가지 이상의 결과로 진행될 수 있다. 결과에 대한 의도가 없으면 상관없지만,
트랜잭션을 걸 수 밖에 없다.
●ATM기 현금을 넣는데 롤러에 이상이 생겨 현금을 세다(입력)가 작업이 멈췄다. 그러면 전부 빼주는게 트랜잭션의 개념.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<5>오라클에서 [계정]이란?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
ID와 계정의 구분! ID는 모든 사람이 들어봤을 때 똑같은 권한을 누릴 수 있는것.(ex 네이버 회원가입)
계정은 ID에 권한이 추가된 것.

●오라클에 접속하는 사용자를 말한다.
●사용자마다 권한을 다르게 줄 수 있다.
●오라클은 다수의 클라이언트에게 동시에 정보를 제공하는 서버이므로 서버의 특징인 계정과 암호를 가지고 있다.
-----------------------
<참고>서버(SERVER)?
-----------------------
	다수의 클라이언트에게 동시에 정보를 제공하는 H/W나 S/W를 말한다.

●오라클 계정의 종류 (입, 오라클 Default 계정을 적어주세요. 1,2,3)
	----------------------------------------------------------------------------------------------
	1. SYS 	  -> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다. 반지의 제왕!
		      최종관리자 개념으로 이해하고, 계정 노출이나 분실 시 모든 데이터를 날릴 수 있음.
	---------------------------------------------------------------------------------------------
	2. SYSTEM -> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다.
		      단, [데이터베이스] 생성 권한이 없다. 이것 또한 최종 관리자 개념.
	----------------------------------------------------------------------------------------------
	3. SCOTT	  -> 오라클 설치 시 기본적으로 만들어지는 계정. DB에 영향을 줄만한 권한이 거의 없음.
		      구경꾼 같은 개념.
	----------------------------------------------------------------------------------------------
	4. 생성 계정-> 계정 생성 권한을 가진 계정이 만드는 계정으로 계정 별 권한이 설정된다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<6>데이터베이스 차원에서 스키마(Schema)란? (입, 기, 실) 대형 솔루션 회사 시험 타겟!!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<주의> Schema 스펠링
●[데이터베이스의 구조]에 대한 정의와 제약조건 등을 기술한 [명세서]를 말한다.
●[계정]이 생성한 모든 [객체]들을 의마한다. (오라클 객체 => 테이블, 뷰, 인덱스, 프로시저, 트리거 등)
 객체들이 DB구조에 대한 정의와 이에 대한 제약조건 등을 기술한 [명세서]이기 때문이다.
●[kim]이라는 계정으로 들어가서 만든 모든 객체(테이블, 뷰, 인덱스 등)를 [kim schema] 라고함

abc계정 -> employee 테이블 생성 -> abc.employee 형태로 저장됨
kim계정 -> employee 테이블 생성 -> kim.employee 형태로 저장됨
kim계정 -> employee 테이블 생성안됨. 뒤에 동일한 테이블(객체)이 존재하기 때문에
동일한 계정에서 동일한 객체 이름은 만들 수 없다.

○스키마는 한 번 정의되면 자주 바뀌지 않으며, 스키마에 따라 실제로 저장된 값(인스턴스, instance)은 계속 변하는 특징이 있다. 예를 들면, 건물을 지어놓으면 구조는 거의 변하지 않지만 건물에 들어오는 상가, 오가는 사람들은 계속 바뀌기 때문이다.

○(외개내)외부 스키마, 개념 스키마, 내부 스키마
 - 외부 스키마(=서브스키마) => 사용자 관점의 스키마로 일부 데이터베이스를 서로 다른 관점(View)에서 정의하도록 지원하는 추상화의 최상위 단계.
- 개념 스키마 => 응용 프로그래머나 사용자가 필요로 하는 자료를 통합해놓은 것. 전체의 데이터베이스로 하나만 존재함.
- 내부 스키마 => 자료가 실제로 저장되는 방법을 기술. 저장 장치 입장에서 본 데이터베이스의 물리적 명세. 추상화의 최하위 단계이며 개념 스키마에 대응되는 하나의 내부 스키마가 생성.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<7> 데이터베이스 차원에서 테이블(table)이란?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●RDBMS에서 데이터가 실질적으로 저장되는 [논리적 장소(=S/W적인 장소)]를 말한다.
●[컬럼(coloumn=열)]과 [로우(row=행=record)]로 구성되어 있다.
●테이블은 이름을 가지고 저장되는 객체의 한 종류이다.
●개발자 입장에서 제일 손이 많이 가는 객체이다.
●테이블에 데이터를 입력하는 SQL은 DML - INSERT이다. (DML, Date Manipulation Language, 데이터 처리 언어)
●테이블에 데이터를 수정하는 SQL은 DML - UPDATE이다.
●테이블에 데이터를 삭제하는 SQL은 DML - DELETE이다.
●테이블에 데이터를 입력하는 SQL은 DML - SELECT이다.★★★★★


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<8> 테이블(table)을 생성하는 SQL구문의 형식은?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
DDL(Data Definition Language, 데이터 정의 언어) - CREATE(객체생성)
----------------------------------------
CREATE TABLE 테이블명(
	컬럼명1   자료형   제약조건
	,컬럼명2  자료형    제약조건
	,컬럼명n	자료형    제약조건
);
----------------------------------------
CREATE TABLE 테이블명(
	컬럼명1   자료형   제약조건,
	컬럼명2   자료형   제약조건,
	컬럼명n	자료형    제약조건
);
----------------------------------------
컬럼(column)은 이론적으로 1개 이상이면 되지만, 실무적으로 볼 때는 2개 이상임
콤마(,)의 위치는 전자, 왼쪽에 있는게 가독성이 좋다.
뒤에 붙으면 (,)가 잘 안보여서 오류 잡기가 어려움
맨 마지막줄 주석처리 시, 이전 줄 마지막에 붙은 (,) 때문에 데이터 처리가 불편함

----------------------------------------
CREATE TABLE 테이블명(
	컬럼명1   자료형   제약조건
	,컬럼명2  자료형    제약조건
	,컬럼명n	자료형    제약조건
);
----------------------------------------
	------------------------------------
	(입)자료형(Data type) => 테이블의 컬럼(column)에 입력된 데이터의 유형을 말한다. 문자형, 숫자형, 날짜형 등이 있다.
	------------------------------------
	(입, 기)제약조건 => 입력되는 데이터의 입력 가능 조건을 말한다. 제약조건에 위배되는 데이터는 삽입될 수 없다.
		    제약조건이 생략되면 데이터가 입력되지 않을 경우 null이 저장된다.
		    입력되는 데이터의 자료형을 조건으로 종류가 굉장히 많다.

		[테이블에 들어가기 위한 제약조건]

		셀 하나만 못들어가는게 아니라 행 단위로 들어가지 못함.
		데이터가 중복되는 경우에도 데이터가 들어가지 못함.
		술집에 갔는데 일행 중 한명이 민증이 없어서 모두 나옴.

		행 단위 데이터 입력이 안되는 경우 ( 1. 자료형 위배, 2. 제약조건 위배 )
	------------------------------------
	<주의>테이블명, 컬럼명 제작 규칙
		▷ 영문자, 1~9, $, #, _ 로 구성되고 반드시 영문자로 시작해야 한다. (0은 안돼!)
		▷ 30자를 초과할 수 없다. SQL 예약어는 사용할 수 없다.
		▷ 하나의 계정이 만든 테이블명은 유일해야 하고 하나의 테이블 안에서 컬럼명은 유일해야한다.
		▷ 테이블명, 컬럼명, 제약조건명을 " 로 감싸거나 " 없이 그냥 써도 된다.
		▶▶ 중요) 가독성이 좋게 만들어야한다. 영어로 치환하기 어려운 단어는 발음 그대로 사용하기도 한다.
		▷ 테이블이 엄청 많은 자료의 경우. 약어로 작성하고 별도의 약어 메뉴얼을 만들기도 한다.


	1. 자바에서 "와 '가 언제 사용되는지 설명하시오.
		String형 = "",  Char형 ''

		String str1 = "산"; 오류없음.
		String str2 = '산'; 오류발생. 변수선언이 우선이므로 '산'에 오류가 있다고 판단.
		char str3 = '산너머'; 오류발생. 문자 1개를를 가져와야하는 char형 데이터인데 3개나 들어가서 오류.
		String str4 = '산너머'; 오류발생. String형 변수를 표기하는 "산너머"가 char형 '산너머'로 표기됨.


	자바의 데이터 종류
		기본형 => byte, short, int, long, char, boolean, float, double
		참조형 => 객체의 메모리 위치 주소값을 말한다.

		StringBuffer sb = new StringBuffer();
		sb.append("전수안");
		sb.append("변희원");

		sb라는 객체의 메모리 위치 주소값
		참조형은 객체에 접근하기 위한 주소값, append 메소드를 호출하기 위해

		String name1 = "손오공";  >> 참조형
		String name1 = '손';  >> 오류발생. 변수선언이 먼저이기 때문에 '손'을 "손"으로 고쳐주는게 우선시된다.
		char name2 = '손';  >> 기본형
		String name1 = new String("손오공");
		>> 원래 형식은 이런 형태인데, 문자열은 많이 사용하기 때문에 기본형의 형태로 작성할 수 있는 것뿐이다.

		기본형 외에 있는 데이터는 모두 참조형. 그 객체의 메모리 위치 주소값을 나타낸다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<9> 오라클에서 자료형의 종류는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

크게 3가지(문자형, 숫자형, 날짜형 등)
오라클은 대문자가 원칙이나, 소문자를 써도 상관은 없다.

	3세대 자료형(java)의 대표적 특징
	String banjang = "변희원";  // 문자형 ""이라는 정해진 강제성
	int age = 22;
	--------------------------------------
	4세대 자료형(Oracle) = SQL
	slect b_no , subject from goard  // 대화형태로 만들어져 접근이 쉽지만, 고객요구사항을


	▷숫자인데 문자취급하는 경우 => 증감이나 수학적 연산이 이루어지지 않는 경우!


----------------------------------------
CREATE TABLE 테이블명(
	컬럼명1   자료형   제약조건
	,컬럼명2  자료형    제약조건
	,컬럼명n	자료형    제약조건
);
----------------------------------------

-------------------
CHAR(s)
-------------------
	▶고정길이 문자열 저장, s는 byte 수를 의미
	▶설정 크기보다 입력 문자 크기가 작으면 공백으로 남는다.
		=> 데이터 길이가 일정한 경우에 사용(ex 주민등록번호)
	▶설정 크기보다 입력 문자 크기가 크면 행 자체가 입력되지 않는다.
	▶<예>CHAR(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개, 한글 2개까지 가능
		<참고> 영문1자는 1byte, 한글 1자는 2byte  차지.
	▶최대 크기는 2000 byte이다. (영문 2000자, 한글 1000자)
	▶CHAR는 CHAR(1)과 동일.
	▷고객요구사항에 의해서 데이터의 길이가 바뀔 수 있기 때문에 현장에서는 사용하지 않는 경우가 많다.



-------------------
VARCHAR2(s)
-------------------
	▶▶가변길이 문자열 저장.
	▶s는 byte 수를 의미. (이름, 주소 같이 데이터가 일정하지 않은 경우)
	▶설정 크기보다 입력 문자 크기가 작으면 크기가 자동으로 줄어든다.
		하지만 DB 서버의 부담은 증가한다.
	▶설정 크기보다 입력 문자 크기가 크면 행 자체가 입력되지 않는다.
	▶<예>CHAR(4) => 문자 4byte 까지 입력 가능. 즉 영문 4개, 한글 2개까지 가능
		<참고> 영문1자는 1byte, 한글 1자는 2byte  차지.
	▶보통 테이블을 설계할 때는 CHAR 타입보다는 VARCAHR2 타입을 많이 사용한다.
	   임의의 컬럼의 입력값 길이를 정확하게 예측하더라도 나중에 변경될 가능성이 많기 때문이다.
	▶최대 크기는 4000 byte 이다. (영문 4000자, 한글 2000자)
	▶VARCHAR2는 (1) 생략이 없다. 무조건 괄호가 들어가야된다.
	▷개발 과정에서 자료형은 넉넉하게 준다. 타이트하면 부족할 때 문제의 소지가 있다.


-------------------
NUMBER2(p,s)
-------------------
	▶정수형 또는 실수형 숫자 저장. (자바와는 다르게 NUMBER하나로 정수와 실수 모두 다룸)
	▶p(precision) => 전체 자릿수(1~38). s(scale) => 소수점이하 자릿수(-84~127)
	▶s 생략 가능. 생략 시 디폴트 0 설정.
	▶NUMBER는 p(precision), s(scale) 모두 생략 시 정수, 소수점이하 자릿수 합쳐 40자리까지 저장.
		이론적인 개념이고 실제로 사용하지는 않는 경우가 대부분.
	▶ 소수점 자릿수가 넘치면 반올림하고, 정수 자릿수가 넘치면 오류가 난다. 행 자체 입력 불가.
	----------------
	▶<예> NUMBER(6, 2)라고 지정한 컬럼에 1234.56 저장하면? 그대로 1234.56 저장됨 (입)
		6 = 정수,소수 포함한 모든 숫자 자릿수 / 2 = 소수점 이하 자릿수
		1234.56 (정수4개, 소수2개 = 6개)
	▶<예> NUMBER(6, 2)라고 지정한 컬럼에 1234.567 저장하면? 1234.57 저장.
		반올림 후 소수점 2자리까지.	정수가 넘치면 입력되지 않는다. 소수는 반올림 후 입력된다.
	▶<예> NUMBER(6, 2)라고 지정한 컬럼에 12345.6 저장하면? 저장 오류. 정수 자릿수 부족으로 오류 발생.
		소수자릿수 2개
	----------------
	▶<예> NUMBER(3)라고 지정한 컬럼에 123 저장하면? 123 저장.
		(p, s)두번 째 옵션 s 는 소수점 이하 자릿수. 정수형 자료만 입력되는 경우임.
	▶<예> NUMBER(3)라고 지정한 컬럼에 123.4 저장하면? 123 저장.
		소수점 자릿수 반올림해서 저장.
	▶<예> NUMBER(3)라고 지정한 컬럼에 1234 저장하면? 정수부문 자릿수 부족으로 오류 발생.

	삼성직원 테이블의 직원고유번호 1부터 시작하는 컬럼은 NUMBER( 직원의 최대 인원수 )
	국내 백신 투여 인원을 카운팅하는 컬럼 NUMBER(8) 대략 천만명 단위
	학원에 다니는 학생 번호가 들어가는 컬럼 NUMBER(3) KOSMO기준 백명단위


-------------------
DATE
-------------------
	▶[년, 월, 일, 시, 분, 초] 저장. ★★★★★
	▶저장 범위는 BC 4712년 1월 1일~9999년 12월 31일.
	▶<참고>보통 날짜형 데이터는 SQL문장에서 [TO_CHAR] 반환함수, [TO_DATE] 반환함수와 같이 사용된다.
		"투 언더바 차", "투 언더바 데이트"

	--------------------------------------------------------------
	반환함수 (입)

	TO_CHAR => 날짜를 문자로 예쁘게 정리해서 출력
	TO_DATE  => 날짜문자를 날짜로 출력
	TO_NUMBER => 숫자문자를 숫자로 출력

	--------------------------------------------------------------

	▶<참고>2021년 6월 11일 부터 ▶ 2021년 12월 25일 까지 남은 일수 검색하는 SQL 구문 작성?
		--------------------------------------------------------------
		SELECT TO_DATE('20211225', 'YYYYMMDD') - TO_DATE('20210611', 'YYYYMMDD') from dual
		--------------------------------------------------------------

	▶<참고>오늘 날짜를 예쁘게 연-월-일로 검색하는 SQL 구문 작성?
		--------------------------------------------------------------
		select to_char(sysdate. 'YYYY-MM-DD') from dual
		--------------------------------------------------------------

	▶<참고>반환함수는 [TO_CHAR], [TO_DATE], [TO_NUMBER]와 같이 사용된다.

	앞에 위치한 TO_DATE구문과 뒤의 TO_DATE구문이 동일한 형식을 갖추고 있어야함. 'YYYYMMDD'
	--------------------------------------------------------------


-------------------
<참고>기타 문자형에는 CLOB, LONG, NCHAR(s), NVARCHAR2(s), NCLOB 등이 있다.
<참고>기타 숫자형에는 BINARY_FLOAT, BINARY_DOUBLE도 있다.
<참고>기타 날짜형에는 TIMESTAMP(f), TIMESTAMP(f) WITH TIME ZONE, TIMESTAMP(f) LOCAL WITH TIME ZONE 도 있다.
-------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<10> 오라클에서 제약조건의 종류는? (입, 기, 실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

-------------------
not null
-------------------
	▶반드시 데이터가 입력돼야 한다. 비어있으면 안돼!
		필수입력 데이터.

-------------------
unique
-------------------
	▶중복되는 데이터는 입력 불가능하다. 중복금지!
	▶<예>사원번호, 주민번호, 전화번호, 아이디 등등
	▶중복되지 않는 데이터는 중요한 데이터이므로 not null도 같이 따라온다.
	▶일반적으로 또는 관용적, 실무적으로 unique를 가진 컬럼은 not null도 같이 들어간다.
		unique는 not null을 동반하지만, not null은 unique를 무조건 동반하는건 아니다.

	▶null 값은 예외적으로 여러 개 입력 가능하다.

-------------------
default
-------------------
	▶데이터를 입력하지 않으면 디폴트로 설정한 값이 입력된다.
	▶<예>회원가입할 때 가입날짜를 입력하지 않아도, 그 당일날짜가 저장되는 경우
		내가 선택하지 않았음에도 기본적으로 설정한 값이 입력됨.
	▶공백이 없이 기본으로 입력되는 데이터이기 때문에, not null의 성격을 가진다.

-------------------
check
-------------------
	▶지정한 데이터만 입력 가능하다.
	▶<예>성별 입력 시 남 또는 여만 입력되는 경우.

-------------------
primary key(PK)★★★★★
-------------------
	▶not null, unique의 제약조건 성질을 가진다. 즉 행과 행을 구분할 수 있는 유일한 데이터가 입력된다.
	▶차후에 foreign key에 의해 참조 당할 수 있는 키다. 필수는 아님.
	▶행과 행을 구별하는 절대적인 데이터를 주는 컬럼은 PK를 부여함
	▶PK는 한 개의 테이블에 한 개까지 존재할 수 있다. (0~1개)
		이론적으로는 PK가  0개도 가능하지만 실무적으로는 1개가 반드시 들어가있다.
	▶[기본키], [주 키]라고도 한다.


-------------------
foreign key(FK)★★★★★
-------------------
	▶primary key에 존재하는 데이터만 삽입될 수 있다. (=primary key를 참조하는 key다.)
	▶<주의> 예외적으로 null값 입력이 가능하다. 즉, 데이터가 입력되지 않을 수 있다.
	▶하나의 테이블에 0개 이상 (0, 1, 2, ... ) foreign가 사용될 수 있다.
	▶table 간의 관계를 설정하는 키다. (PK는 참조 당하는 수동적인 느낌, FK는 참조하는 능동적인 느낌)
	▶[참조키], [외래키], [관계키], [종속키] 라고도 한다.



▶PK => not null, unique, fk가 참조할 수 있는 데이터
▶참조하는 PK가 있는 FK 행, 테이블이 있으면 해당 PK가 있는 행, 테이블은 삭제할 수 없다.
▶참조당하는 PK가 있는 행, 테이블을 지우기 위해서는 해당 PK를 참고하고 있는 FK 행, 테이블을 삭제해야한다.
▶PK와 FK의 관계가 다른 테이블에 복잡하게 얽혀있으면 지우고자 하는 행과 연결되어있는 참조 관계를 추적해야한다.


		dept
============================================
dep_no(PK)     dep_name
============================================
10             관리부
20             자재부
30             홍보부
40             사업부


                     employee
============================================
e_no(PK)     e_name    dep_no(FK)    salary  jikup     mgr_e_no(FK)
============================================
1         사오정       10            5000     대리       3
2         저팔계       20            6000     과장       3
3         손오공       30            7000     부장       null
4         사오정       40            5000     대리       2


           		 customer
============================================
c_no(PK)     c_name    phone  e_no(FK)
============================================
1         사오순        ~     2
2         저팔순        ~     4
3         손오순        ~     1
4         사오순        ~     2



e_no => number(n) / not null, unique, fk가 참조할 수 있는 데이터
e_name => varchar2(n) / not null
dep_name => varchar2(n)
salary => number(n), dafault
jikup => varchar2(n)

	        employee
===========================
e_no(PK) 	e_name  dep_name  salary   jikup
===========================
1	 사오정  	  관리부	   5000	  대리
2 	 저팔계	  영업부	   6000     과장
3	 손오공	  자재부	   7000 	  부장

	        customer
===========================
c_no   	c_name     phone    e_no(FK)
===========================
1	변희원  	  1203	     1
2	김영민	  1255	     4 => 오류발생

FK에 의해 PK를 불러오는데, PK에 없는 데이터가 작성되면 행 자체가 입력되지 않는다.

PK가 있으면 FK는 필수적으로 존재하지 않음
FK가 있으면 PK는 필수적으로 존재함


210611 QUIZ
---------------------------------------------------
FK 가 있으면 반드시 PK 가 있다. O
 - PK가 없으면 FK도 없다.
 - FK가 없어도 PK는 있을 수 있다.
---------------------------------------------------
unique 가 걸린 컬럼에는 반드시 not null 이 걸린다.. X
 - 반드시 not null이 걸리지 않는다. 실무적으로 not null이 따라갈 뿐.
---------------------------------------------------
자료형도 데이터를 걸러내는데 사용된다. O
 - 입력되는 데이터는 자료형과 제약조건을 통해서 필터링됨.
---------------------------------------------------
not null 이 걸린 컬럼에는 반드시  unique 가 걸린다.. X
 - 반드시 unique가 걸리지 않는다. 필요에 의해 걸 수 있다.
---------------------------------------------------
셀을 삭제하는 명령어는 update 이다. O
 - 행을 삭제하는 명령어는 delete
---------------------------------------------------
행 삭제는 alter 구문이다. X
 - 행 삭제는 delete, alter는 객체 수정(DDL)
---------------------------------------------------
행 수정은 update 구문이다. X
 - 행 수정은 없고, 셀 수정의 update구문이 있다.
---------------------------------------------------
create 로 만든 테이블은 rollback 으로 없앨수 있다. X
 - DDL create로 만든 테이블은 자동으로 commit되고 rollback할 수 없다.
---------------------------------------------------
select 도 트랜잭션을 걸수 있다. O
 - 걸 수는 있으나 아무런 의미가 없다. 실무적으로 insert, update, delete에 각각 트랜잭션을 걸기에 번거로움이 있어 select까지 한꺼번에 묶어서 트랜잭션을 건다.
---------------------------------------------------
default 가 걸리면 대부분 not null 이다. O
 - default로 입력될 데이터가 있기 때문에,,


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<11> 시퀀스(sequence)란? (입50%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
●[고유 일련 번호]를 생성해서 제공하는 객체이다. 일종의 [일련번호 생성기]이다.
●주로 하나의 테이블에서 PRIMARY KEY로 지정된 컬럼명에 입력될 [일련번호]값을 생성한다.
●<비유>은행에서 번호표 뽑는 기계와 동일한 기능을 가진다.
------------------
●시퀀스 생성 SQL 구문
------------------
	-------------------------------
	create sequence 시퀀스명
			start with 시작값
			increment by 증가값
			minvalue 최소값
			maxvalue 최대값;
	-------------------------------
	예
	-------------------------------
	create sequence sq_emp
			start with 1
			increment by 1
			minvalue 1
			maxvalue 9999;
------------------
●증가된 새 일련번호 얻는 SQL 구문
------------------
	시퀀스명.nextval
------------------
●마지막으로 이미 뽑혔던 일련번호 얻는 SQL 구문
------------------
	시퀀스명.currval
------------------
●시퀀스 삭제 SQL 구문
------------------
	drop sequence 시퀀스명;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<12> 오라클을 연습하려면 어떤 SW를 설치해야 하나요?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<1>개발자 용 오라클 버전(=OracleXE ) 을 설치한다. system 계정의 비밀번호는 123 으로 한다.
<2>오라클 접속 툴의 한 종류인 Sqlgate 를 설치한다.
<3>Sqlgate 를 실행하고 아래 사항을 입력한 후 접속을 한다.
▶IP        => localhost
▶사용자       => system
▶암호        => 설정암호
▶SID(서비스명) => XE


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<13> system 계정으로 접속하니 쓸 데 없는 테이블이 많아 번거롭다.
	 system 계정과 동일한 권한을 가지는 새로운 계정을 만드려면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
① system 계정으로 접속한 후 코딩 창에서 아래 와 같은 명령으로 king 계정을 만들고 암호는 k123 으로 한다.
	create user king  identified by k123;

② 아래 와 같은 명령으로 king 계정에 system 계정과 동일한 권한을 부여한다.
	grant connect,resource,dba to king;

③ Sqlgate에서 king 계정으로 재 접속을 시도한 후 아래 사항을 입력한 후 접속을 한다.
	●IP         => 127.0.0.1 또는 localhost
	●사용자       => king
	●암호        => k123
	●SID(서비스명) => XE


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<14> 아래 고객 요구사항에 맞는 테이블을 만들면?   -- SQL_02.sql에 정답 기재돼있음. 혹은 SQL210615.sql
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
부서정보를 관리하고 싶어요. 부서정보는 부서명, 부서위치입니다.

직원정보를 관리하고 싶어요. 직원정보는 직원명, 직급, 연봉, 입사일, 주민번호, 핸드폰번호, 직속상관번호, 연봉등급입니다.

고객정보를 관리하고 싶어요. 고객정보는 고객명, 전화번호, 주민번호, 담당직원명입니다.

연봉등급정보를 관리하고 싶어요. 연봉등급정보는 연봉등급, 최저연봉, 최고연봉입니다.

----------------------------------
-- dept 테이블 생성 (부서정보 - 부서명, 부서위치)
----------------------------------
create table dept(
  dep_no        number(3)                        -- 부서번호 저장 컬럼 선언. 자료형은 숫자형
  ,dep_name     varchar2(20)    not null unique  -- 부서명 저장 컬럼 선언. 자료형은 문자형. 제약조건 비지마. 중복마.
  ,loc          varchar2(20)    not null         -- 부서위치 저장 컬럼 선언. 자료형은 문자형. 제약조건 비지마.
  ,primary key(dep_no)                           -- pk선언(dep_no이 언젠가 참조될 수 있다) 비지마. 중복마.
);

----------------------------------
-- dept 데이터 (부서정보 데이터 입력 - 부서번호, 부서명, 부서위치)
		부서번호를 입력하는 이유는 pk로 지정하기 위해서.
----------------------------------
-- 행 입력하기(총 4행) insert into 테이블명(객체명) values(객체 데이터 입력)
insert into dept(dep_no, dep_name, loc) values( 10, '총무부', '서울'); -- 문자는 ' '로 감싼다.
insert into dept(dep_no, dep_name, loc) values( 20, '영업부', '부산');
insert into dept(dep_no, dep_name, loc) values( 30, '전산부', '대전');
insert into dept(dep_no, dep_name, loc) values( 40, '자재부', '광주');

----------------------------------
-- employee 테이블에서 pk값으로 사용할 일련번호를 생성하는 시퀀스 생성하기(일련번호 자동 생성기)
-- 특정테이블에 pk값(일련번호)을 자동으로 입력하게끔 만들기 위해서
----------------------------------
create sequence emp_sq
-- create sequence 테이블약어_시퀀스
    start with 1       -- 시작값
    increment by 1     -- 증가값
    minvalue 1         -- 최소값 1(-값으로 내려가는 경우도 생각)
    maxvalue 999;      -- 최대값

----------------------------------
-- employee 테이블 생성. 직원정보 저장.(직원번호, 직원명, 부서번호, 직급, 연봉, 입사일, 주민번호, 전화번호, 직속상관직원번호)
----------------------------------
create table employee(
    emp_no      number(3)                        -- 직원번호 컬럼 선언. 숫자형.
    ,emp_name   varchar(20)     not null         -- 직원명 컬럼 선언. 문자형. 비지마.
    ,dep_no     number(3)                        -- 부서번호 컬럼 선언.(fk, pk에 있는 데이터만 들어올 수 있기 때문에 일관성과 정확성을 지킬 수 있음)
    ,jikup      varchar2(20)    not null         -- 직급 컬럼 선언. 비지마.
    ,salary     number(9)       default 0        -- 연봉 컬럼 선언. 숫자형. 안주면 0 줄게. default값이 숫자형과 동일한 자료형
    ,hire_date  date            default sysdate  -- 고용일자 컬럼 선언. 날짜형. 안주면 현재 년월일시분초 줄게
    ,jumin_num  char(13)        not null unique  -- 주민번호 컬럼 선언. 비지마. 중복마. 개발과정에서는 unique를 빼고 진행(샘플데이터를  통해 동일한 값이 입력될 수 있기 때문에)
    ,call_num   varchar2(15)    not null         -- 전화번호 컬럼 선언. 비지마. (중복마도 들어가는 추세)
    ,mgr_emp_no number(3)                        -- 직속상관직원번호 컬럼 선언. (fk, 동일한 테이블 내의 pk를 참조함)

    ,primary key(emp_no)                         -- emp_no 직원번호 컬럼 pk제약조건. 비지마. 중복마.
    ,foreign key(dep_no)    references dept(dep_no)  -- dep_no 부서번호 컬럼 fk제약조건. dept테이블 dep_no 참조.
    ,constraint employee_mgr_emp_no_fk foreign key(mgr_emp_no) references employee(emp_no)
    -- employee_mgr_emp_no_fk는 제약 조건에 붙이는 이름.
    -- 직속상관직원번호 fk 제약조건. 동일 테이블 pk(emp_no)
    -- fk에 제약조건을 준 이유 => 나중에 무력화시키기 위해서 => fk가 같은 테이블 내 pk를 참조하면서 서순 상으로 데이터를 가지지 못하는 경우도 있기 때문에.
	-- 예시)직원번호 4번 이미라는 직속상관직원번호가 17번이다. 하지만 4번 행이 입력중이기 때문에 17번 행은 아직 데이터가 입력돼있지 않아서 오류가 발생할 수 있다.
    -- fk 설정코드 => foreign key(소속테이블 내 컬럼명) references 참조할테이블명(참조테이블 내 pk 컬럼명)
);

-------------------------------------------------
--●employee_mgr_emp_no_fk 라는 이름의 FK 제약조건 끄기(임시 무력화)
-------------------------------------------------
alter table employee disable constraint employee_mgr_emp_no_fk;
-- mgr_emp_no이 없는 경우(17),  제약조건을 잠시 무력화시키는 명령어 disable
-- 객체(테이블)의 구조를 바꾸기 때문에 alter 명령어 사용. =>> 테이블 내의 [데이터]를 수정하는 경우 update // 구분필요


-------------------------------------------------
-- 지금 현재 로그인한 계정이 날짜 데이터는 '년-월-일'로 취급하게 하기(날짜데이터 인식방법 변경)
-- 기본 날짜형식은 '일/영문 월/년도'이다. '1980-01-01' >> to_date('1980-01-01', 'YYYY-MM'DD')
-------------------------------------------------
alter session set nls_date_format = 'yyyy-mm-dd';

-------------------------------------------------
-- employee 테이블에 행 입력하기(총 20행)
-------------------------------------------------
-- sequence 입력 => emp_sq.nextval <= 지정해준 시퀀스명을 통해서 .nextval 입력해주면 시작값을 기준으로 일련번호가 나열됨.

insert into employee values( emp_sq.nextval, '홍길동', 10, '사장', 5000, '1980-01-01', '7211271109410', '01099699515', null );
insert into employee values( emp_sq.nextval, '한국남', 20, '부장', 3000, '1988-11-01', '6002061841224', '01024948424', 1 );
insert into employee values( emp_sq.nextval, '이순신', 20, '과장', 3500, '1989-03-01', '6209172010520', '01026352672', 2 );
insert into employee values( emp_sq.nextval, '이미라', 30, '대리', 2503, '1983-04-01', '8409282070226', '01094215694', 17 );
insert into employee values( emp_sq.nextval, '이순라', 20, '사원', 1200, '1990-05-01', '8401041483626', '01028585900', 3 );
insert into employee values( emp_sq.nextval, '공부만', 30, '과장', 4003, '1995-05-01', '8402121563616', '01191338328', 17 );
insert into employee values( emp_sq.nextval, '놀기만', 20, '과장', 2300, '1996-06-01', '8011221713914', '01029463523', 2 );
insert into employee values( emp_sq.nextval, '채송화', 30, '대리', 1703, '1992-06-01', '8105271014112', '01047111052', 17 );
insert into employee values( emp_sq.nextval, '무궁화', 10, '사원', 1100, '1984-08-01', '8303291319116', '01025672300', 12 );
insert into employee values( emp_sq.nextval, '공부해', 30, '사원', 1303, '1988-11-01', '8410031281312', '01027073174', 4 );
insert into employee values( emp_sq.nextval, '류별나', 20, '과장', 1600, '1989-12-01', '8409181463545', '01071628290', 2 );
insert into employee values( emp_sq.nextval, '류명한', 10, '대리', 1800, '1990-10-01', '8207211661117', '01042072622', 20 );
insert into employee values( emp_sq.nextval, '무궁화', 10, '부장', 3000, '1996-11-01', '8603231183011', '01098110955', 1 );
insert into employee values( emp_sq.nextval, '채시라', 20, '사원', 3400, '1993-10-01', '8001172065410', '01044452437', 3 );
insert into employee values( emp_sq.nextval, '최진실', 10, '사원', 2000, '1991-04-01', '8303101932611', '01027491145', 12 );
insert into employee values( emp_sq.nextval, '김유신', 30, '사원', 4000, '1981-04-01', '7912031009014', '01098218448', 4 );
insert into employee values( emp_sq.nextval, '이성계', 30, '부장', 2803, '1984-05-01', '8102261713921', '0165358075', 1 );
insert into employee values( emp_sq.nextval, '강감찬', 30, '사원', 1003, '1986-07-01', '8203121977315', '01033583130', 4 );
insert into employee values( emp_sq.nextval, '임꺽정', 20, '사원', 2200, '1988-04-01', '8701301040111', '01086253078', 7 );
insert into employee values( emp_sq.nextval, '깨똥이', 10, '과장', 4500, '1990-05-01', '8811232452719', '01090084876', 13 );

select * from employee;  -- 테이블명에 있는 * 모든 데이터 검색


insert into employee values( 1, '홍길동', 10, '사장', 5000, to_date('1980-01-01','YYYY-MM-DD'), '7211271109410', '01099699515', null);

●기본 날짜형식 '일-영문월-년도' / '1980-01-01' >> to_date('1980-01-01', 'YYYY-MM'DD')

●FK에 null값을 입력하는 경우 2가지.
처음 들어가는 데이터는 참조할 자료가 없는 경우
나중에 입력하기 위해 유보하는 경우

●시퀀스 사용하여 많은 데이터의 일련번호 작성


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<15> employee 테이블에서 모든 컬럼, 모든 행의 데이터를 검색하면?  (15~34 기사, select 활용)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select 구문은 원본데이터에 대한 개입이 일어나지 않는 가상상태의 작업으로 이후 결과를 클라이언트에게 출력해줌

	select * from employee;
	-- *는 위의 모든 컬럼명을 통칭하는 역할(create로 테이블을 만들 때, 순서 그대로의 모든 컬럼명)
	-- *로 만든 select는 create로 만든 순서 그대로 출력된다.
	-- 원하는 순서로 출력하기 위해서는 하나하나 컬럼명을 입력해준다.

	select emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, call_num, mgr_emp_no from employee;
	-- 원래 select 뒤에 검색하고자 하는 컬럼명을 다 작성해야한다.

	select
		emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, call_num, mgr_emp_no
	from
		employee;
	-- 가독성을 높이는 법1

	select
		emp_no
		,emp_name
		,dep_no
		,jikup
		,salary
		,hire_date
		,jumin_num
		,call_num
		,mgr_emp_no
	from
		employee;
	-- 가독성을 높이는 법2


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<16> employee 테이블에서 emp_no, emp_name, dep_no, jikup, salary, hire_date 컬럼의 데이터를 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no
		,emp_name
		,dep_no
		,jikup
		,salary
		,hire_date
	from
		employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<17> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 을 검색하면서
	별칭(=alias)을 즉, 헤더를 사원번호, 직원명, 직급, 연봉, 입사일로 하고 연봉에 '만원'이라는 문자를 붙여 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	별칭(=alias), 헤더.

	select
		emp_no			as "직원번호"
		,emp_name		as "직원명"
		,dep_no			as "부서명"
		,jikup			as "직급"
		,salary||'만원'	as "연봉"
		,hire_date		as "입사일"
	from
		employee;

	-- 헤더는 데이터가 아니기 때문에 " "를 사용한다.
	-- as와 " "는 생략이 가능하다.
	-- 별칭에 공백이 없으면 " "도 생략이 가능하다. 웬만해서는 " "는 꼭 사용해준다.
	-- 테이블이 많은 경우 가독성을 위해 as를 생략하지 않고 사용하기도 한다.
	-- Oracle에서 +는 사칙연산으로만 사용되므로 연결연산자(||)를 통해서 객체데이터 뒤에 '만원'을 넣어줄 수 있다.
	-- Oracle에서 ' '는 문자데이터에서만 사용한다.
	-- 자바, 오라클, 자바스크립트 등에서 사용하는 기호의 용도에 차이가 있다.

	select
		emp_no			as "직원번호"
		,emp_name		as "직원명"
		,dep_no		   	   "부서명"
		,jikup			   "직급"
		,salary||'만원'	    연봉
		,hire_date	     	입사일
	from
		employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<18> employee 테이블에서 직원명, 직급, 연봉, 세금, 실수령액을 검색하면? (세금은 연봉의 12%)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select
		emp_name			as "직원명"
		,jikup				as "직급"
		,salary*0.12||'만원'	as "세금"
		,salary*0.88||'만원'	as "실수령액"
	from
		employee;

	-- 사칙연산을 활용하여 계산할 수 있다. 단, 자료형이 숫자형이어야한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<19> employee 테이블에서 직급을 중복없이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select distinct jikup from employee;
	select unique jikup from employee;

	select distinct (jikup) from employee;
	select unique(jikup)from employee;
	-- distinct 뒤에 중복되는 값을 제거하여 검색
	-- 문제가 제시되고 답을 구할 수도, 답을 먼저 보고 문제를 유추할 수도 있어야 한다.
	-- unique로 대체 가능하며, 컬럼이 2개 이상인 경우 둥근괄호를 제거한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<20> employee 테이블에서 부서번호와 직급을 중복없이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select distinct dep_no, jikup from employee;
	select unique dep_no, jikup from employee;

	select unique dep_no, jikup from employee order by 1;

	select distinct
		dep_no
		,jikup
	from
		employee;

	-- distinct는 두번 이상 사용될 수 없다.
	=> select distinct dep_no, distinct jikup from employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<21> employee 테이블에서 연봉이 3000이상인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary >= 3000;
	-- where 비교컬럼 비교연산자 비교값
	-- 행을 골라내는 키워드
	-- select * from dept where dep_no=10; (부서테이블에서 부서번호가 10인 행만 보여줌)
	-- select에서 원하는 행만 검색해서 보여줌(where절)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<22> employee 테이블에서 연봉 오름차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee order by salary asc;
	select * from employee order by salary ;
	select * from employee order by 5;
	-- order by 컬럼 정렬방식, 오름차순은 생략 가능
	-- 행을 정렬하는 키워드
	-- order by 컬럼순번 을 적으면 해당 숫자만큼의 컬럼을 기준으로 정렬한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<23> employee 테이블에서 연봉 내림차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee order by salary desc;
	select * from employee order by 5 desc;
	-- 5번째 컬럼을 내림차순으로 정렬
	-- 22, 23번 문제는 single sort


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<24> employee 테이블에서 부서번호를 오름차순으로 유지하면서 연봉 내림차순으로 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee order by dep_no asc, salary desc;
	select * from employee order by dep_no , salary desc;
	-- order by 이후에 sort 하고 싶은 컬럼명을 왼쪽부터 순서대로 나열해주면 된다.
	-- asc를 생략 가능하며, 뒤에 desc에 의해 착각할 수 있으니 주의!


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<25> employee 테이블에서 직급이 높은 사람 순서대로 나열해서 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee order by jikup desc;
	select * from employee order by jikup asc;
	-- 위는 오답.
	-- 컴퓨터가 받아들일 수 있는 단순한 정렬기준으로 변환해야한다.
	-- 아래 case구문과 decode을 이용.
	select * from employee order by decode(jikup, '사장',1,'부장',2,'과장',3,'대리',4,'사원',5) asc;
	select * from employee order by decode(jikup, '사장',1,'부장',2,'과장',3,'대리',4,'사원',5) ;
	select * from employee order by decode(jikup, '사장',1,'부장',2,'과장',3,'대리',4,'사원',5) desc;

	select * from employee order by decode(jikup, '사장',1,'부장',2,'과장',3,'대리',4,'사원',5), salary desc;
	-- 직급 오름차순 정렬, 연봉 내림차순 정렬 바로 위 행은 jikup 오름차순 asc가 생략돼있음.
	-- sort는 여러개 사용 가능하다. 단, 기준이 되는 컬럼은 왼쪽부터 순차적으로 진행돼야함.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<26> employee 테이블에서 부장만 검색하면? -- 행 검색
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where jikup='부장';
	-- 데이터베이스에는 == 연산자가 없다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<27> employee 테이블에서 20번 부서의 과장을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 and jikup='과장';
	-- 자바에서는 &&(and)연산자가 오라클에서는 and 로 사용.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<28> employee 테이블에서 20번 부서 또는 과장을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 or jikup='과장';
	-- 자바에서는 ||(or)연산자가 오라클에서는 or 로 사용.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<29> employee 테이블에서 과장 중에 연봉 3400 이상을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where jikup='과장' and salary >= 3400;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<30> employee 테이블에서 실수령액이 4000만원 이상 받는 직원을 검색하면? 단, 세금이 12%라고 가정
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary*0.88 >= 4000;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<31> employee 테이블에서 세금을 제일 많이 내는 직원 순서로 나열하면서
	부서번호가 내림차순이면서 사장이 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where != '사장' order by salary*0.12 desc, dep_no desc;
	select * from employee where != '사장' order by salary desc, dep_no desc;

	select * from employee
		where jikup = '부장' or '과장' or '대리' or '사원'
		order by salary*0.12 desc, dep_no desc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<32> employee 테이블에서 20번 부서 중에 연동 2000~3000 사이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=20 and salary >= 2000 and salary <=3000;
	select * from employee where dep_no=20 and salary between 2000 and 3000;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<33> employee 테이블에서 직속 상관이 없는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where mgr_emp_no is null;
	-- null은 데이터취급을 받지 않는다. 데이터가 아니기 때문에 is 사용. =로 찾을 수 없음.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<34> employee 테이블에서 직속 상관이 있는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where mgr_emp_no is not null;
	-- null값이 아닌 값을 찾을 때 is not






■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<35> 오라클 4대 천왕?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	1. 내장함수		=> 미리 만들어진 단위 프로그램으로 호출하면 특정 작업을 하고 데이터를 리턴
	2. join 		=> 서로 다른 테이블의 컬럼을 횡으로 붙이는 작업
	3. subquery 	=> SQL 구문 안의 또다른 select문
	4. group by 	=> 통계 관련 작업






■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<36> employee 테이블에서 [최소연봉], [최대연봉], [평균연봉], [연봉총합], [총인원수]을
	검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	내장함수 사용하여 데이터를 리턴. 별칭(alias) 사용.

	● 그룹함수
		1. 최소값 min(컬럼명)
		2. 최대값 max(컬럼명)
		3. 평균값 avg(컬럼명)
		4. 총합 sum(컬럼명)
		5. 총수 count(컬럼명)

	● 그룹함수 또는 통계함수(그룹을 지어서 연산을 하는 함수)
		주로 group by 와 같이 사용된다.
		null값은 제외하고 계산한다.

	● count
		null 값이 있으면 해당 데이터는 내장함수 대상에서 제외된다. 제약조건이 not null인 컬럼을 사용
		not null이 아닌 경우 null을 제외한 나머지를 count
		count(컬럼명)
		count(*) 모든 행의 개수


	select
			min(salary)    as "최소연봉"	-- salary 컬럼에서 최소값을 리턴
			,max(salary)   as "최대연봉"	-- salary 컬럼에서 최대값을 리턴
			,avg(salary)   as "평균연봉"	-- salary 컬럼에서 평균값을 리턴. null인 데이터는 제외
			,sum(salary)   as "연봉총합"	-- salary 컬럼에서 합계값을 리턴
			,count(*) 	   as "총인원수"	-- salary 컬럼에서 총개수를 리턴
			--,count(emp_no) as "총인원수"
			--,count(salary) as "총인원수"
	from
			employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<37> 아래 SQL 구문은 무슨 문제의 답인가?
	select count(emp_no) from customer;
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	담당직원이 있는 고객의 수.
	중복을 제거한다면, 고객을 담당하는 담당직원의 수.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<38> 고객을 담당하고 있는 직원의 수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(distinct emp_no) from customer;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39> 직속상관이 있는 직원의 수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select count(mgr_emp_no) from employee;

	<주의>mgr_emp_no 컬럼 안의 데이터가 무엇인지 파악해야한다. 직속상관번호

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<39-2> 부하직원이 있는 직원의 수는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select count(distinct mgr_emp_no) from employee;

	● count에는 업무적 특성이 숨어있어서 사용할 때 구분을 잘해야한다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<40> employee 테이블에서 [직원번호], [직원명], [생일 월-일] 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● 주민번호에 있는 생일을 골라서 추출. ● substr(컬럼명,복사할순서번호,복사할갯수) - 복사의 개념
		시작순서번호 부터 복사할 개수 만큼 복사해서 리턴
		사용빈도가 매우 높다
	● 연결연산자 || 사용가능

	select
		emp_no											    as "직원번호"
		,emp_name										    as "직원명"
		,substr(jumin_num,3,2)||'-'||substr(jumin_num,5,2)	as "생일월일"
	from
		employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<41> customer 테이블에서 모든 컬럼, 모든 행을 검색해서 출력하면?
	단, 주민번호는 901225-2****** 형태로 출력하세요.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● substr, 연결연산자(||) 활용
	● 모든 행이란 말이 나오면 where 절이 없다.
	● 연결연산자(||) 좌우의 문자열을 붙이는 연산자
	● 'tom'||'my' => 'tommy'
	  'tom'||123  => 'tom123'
	● 오라클에서 +는 연결연산자가 아닌 사칙연산자

	select
			cus_no
	        ,cus_name
            ,call_num
            ,substr(jumin_num,1,6)||'-'||substr(jumin_num,7,1)||'******'
            ,emp_no
	from
			customer;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<42> customer 테이블에서 고객번호, 고객명, 담당직원존재여부를 출력하면?
	단, 담당직원번호가 없으면 null 출력하지 말고 '없음' 표시
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	null 처리 함수(nvl)
	nvl(컬럼명,null값이면 출력할 값)
	연결연산자(||) 활용하여 ''를 쓰면, 문자자료형으로 바뀜

	select
			cus_no
	        ,cus_name
            ,nvl(emp_no||'','없음')
	from
			customer;

	--null값이 있으면, 0으로 출력. emp_no가 숫자자료형이기 때문에 ''는 붙이지 않음
	select
			cus_no
	        ,cus_name
            ,nvl(emp_no,0)
	from
			customer;

	------------------------------------
	nvl(컬럼명, null값일 때 대체데이터)
	=> 컬럼명 안의 데이터가 null이 아니면 그냥 놔두고
		null이면 null값일 때 대체데이처를 리턴하는
		[null 처리 내장함수]이다.
	------------------------------------




■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<43> customer 테이블에서 고객번호, 고객명, 담당직원존재여부를 출력하면?
	단, 직원번호가 있으면 '있음', 없으면 '없음'으로 표시
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	null 처리 함수(nvl2)
	nvl2(컬럼명,null값 있으면 출력할 값, 없으면 출력할 값)


	select
			cus_no
	        ,cus_name
            ,nvl2(emp_no,'있음','없음')
	from
			customer;

	------------------------------------
	nvl2(컬럼명,null값이 아닐 때 대체데이터, null값일 때 대체데이터)
	=> 컬럼명 안의 데이터가 null이 아니면 null값이 아닐 때 대체데이터 출력하고
		null이면 null값일 때 대체데이터를 리턴하는 [null 처리 내장함수]이다.
	------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<44> employee 테이블에서 직원번호, 직원명, 직급, 성별을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● 조건문(case when then end),(decode)
	● 함수의 형태는 띄지 않지만 리턴의 형태를 갖추고 있음)
	● case 컬럼명 when 조건 then 리턴 end (부등호, 비교연산자 사용 가능)
	● else는 필요에 따라 생략가능
	● decode(비교할 컬럼),조건,리턴,조건,리턴,나머지 경우 리턴 (부등호 불가)
	● 기존에 존재하고 있는 코딩 패턴에 맞게 작성하는게 중요하다.

	select
			emp_no
	        ,emp_name
			,jikup
            ,case
				substr(jumin_num,7,1)
				when '1' then '남'
				when '3' then '남'
				when '2' then '여'
				when '4' then '여'
			end
	from
			employee;


	● case when then else end
	select
			emp_no
	        ,emp_name
			,jikup
            ,case
				substr(jumin_num,7,1)
				when '1' then '남'
				when '3' then '남'
				else '여'
			end
	from
			employee;


	● 컬럼명도 when 안에 넣을 수 있다.
	select
			emp_no
	        ,emp_name
			,jikup
            ,case
				when substr(jumin_num,7,1)='1' then '남'
				when substr(jumin_num,7,1)='3' then '남'
				else '여'
			end
	from
			employee;

	● 컬럼명을 when 안에 넣어서 연산자에 <=, >= 부등호도 넣을 수 있다. 모두 '남' 출력
	select
			emp_no
	        ,emp_name
			,jikup
            ,case
				when substr(jumin_num,7,1)>='1' then '남'
				when substr(jumin_num,7,1)='3' then '남'
				else '여'
			end
	from
			employee;

	● decode 활용 => 간단해보이지만 가독성이 떨어질 수도 있으니 구문을 잘 정돈해야 좋다.
	  decode는 오라클에서만 사용할 수 있다.
	  decode(비교할 컬럼),조건,리턴,조건,리턴,나머지 경우 리턴

	select
			emp_no
	        ,emp_name
			,jikup
            ,decode(
				substr(jumin_num,7,1)
				,'1','남'
				,'3','남'
				,'여'
			)
	from
			employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<45> employee 테이블에서 직원번호, 직원명, 직급, 출생년도(4자리)를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● case 구문 활용(case when then end)
	case 컬럼명 when 조건 then 리턴 end (부등호 사용 가능)

	select
			emp_no
	        ,emp_name
            ,jikup
			,case
				when substr(jumin_num,7,1)='1' then '19'
				when substr(jumin_num,7,1)='2' then '19'
				else '20'
			end||substr(jumin_num,1,2)
	from
			employee;


	● decode 구문 활용
	- decode(비교할 컬럼), 비교데이터, 리턴, 비교데이터, 리턴, ..., 나머지 경우 리턴 (부등호 불가)
	- 나머지경우는 필요에 의해 생략될 수 있다.
	- 단점 => 같다라는 경우에만 사용된다.
		 => 오라클에서만 사용되는 오라클 전용함수

	select
			emp_no
	        ,emp_name
			,jikup
            ,decode(
				substr(jumin_num,7,1)
				,'1','19'
				,'2','19'
				,'20'
			)||substr(jumin_num,1,2)
	from
			employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<46> employee 테이블에서 직원번호, 직원명, 직급, 출생년대(4자리)를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● case 구문 활용(case when then end)
	case 컬럼명 when 조건 then 리턴 end (부등호 사용 가능)

	select
			emp_no
	        ,emp_name
            ,jikup
			,case
				when substr(jumin_num,7,1)='1' then '19'
				when substr(jumin_num,7,1)='2' then '19'
				else '20'
			end||substr(jumin_num,1,1)||'0년대'
	from
			employee;


	● decode 구문 활용
	decode(비교할 컬럼),조건,리턴,조건,리턴,나머지 경우 리턴 (부등호 불가)

	select
			emp_no
	        ,emp_name
			,jikup
            ,decode(
				substr(jumin_num,7,1)
				,'1','19'
				,'2','19'
				,'20'
			)||substr(jumin_num,1,1)||'0년대'
	from
			employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<47> employee 테이블에서 나이순으로 출력하면? 연장자가 먼저 나오도록
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	●order by + case 활용
	● 출력할 때 조건을 걸어 case문을 쓰지만, 출력문의 정렬(sort)을 위해 조건문(case)사용할 수도 있다.
	● order by 뒤에 정렬기준 컬럼이 나온다. 정렬 기준 컬럼을 case가 끌어 안아서 다른 형태로 바꾼 것이다.
	● order by 컬럼명 또는 컬럼순서번호 또는 컬럼alias가 나올 수 있다.

	select
			*
	from
			employee
	order by
		case
			when substr(jumin_num,7,1)='1' then '19'
			when substr(jumin_num,7,1)='2' then '19'
			else '20'
		end || substr(jumin_num,1,6)

		asc; --asc는 생략가능

	---------------------------------------------------
	아래처럼 하면 안된다. 2000년생이 먼저 나온다. 2000년생은 주민번호상 00으로 시작하기 때문에.
	selet * from employee order by jumin_num asc;
	---------------------------------------------------

	select
			*
	from
			employee
	order by
		decode(
			substr(jumin_num,7,1),'1','19'
			substr(jumin_num,7,1),'2','19'
			'20'
		)||substr(jumin_num,1,6)

		asc; --asc는 생략가능


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<48> employee 테이블에서 직급 순서대로 정렬하여 모든 컬럼을 보이면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	●order by + case 활용
	● order by 뒤에 정렬기준 컬럼이 나온다. 정렬 기준 컬럼을 case가 끌어 안아서 다른 형태로 바꾼 것이다.
	● 직급을 정수로 바꾸어서 정렬

	select * from employee
	order by
		case jikup
			when '사장' then 1
			when '부장' then 2
			when '과장' then 3
			when '대리' then 4
			when '주임' then 5
			else 6
		end
		asc;

	select * from employee
	order by
		decode(jikup,'사장',1
			,'부장',2
			,'과장',3
			,'대리',4
			,'주임',5
			,6
		)
		asc;

	● 숫자문자는 같은 자리수여야만 크기가 숫자와 동일하다
		'111' < '9'
 		 111  >  9

	select * from employee
	order by
		decode(jikup
			,'사장','1'
			,'부장','2'
			,'과장','3'
			,'대리','4'
			,'주임','5'
			,'6'
		)
		asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49> employee 테이블에서 직원번호, 직원명, 입사일(년-월-일) 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● to_char 활용
	● 문자자료가 아닌 자료형을
		to_char(날짜 또는 숫자컬럼명, '출력 시 원하는')
		지정한 날짜 또는 숫자를 원하는 출력문자패턴으로 바꾸어 주는 변환함수의 일종
	● 날짜자료형 - 날짜자료형 = 일 수
	● 시간 관련!
	YYYY 연도
	MM 월
	DD 일
	(DAY, DY, D) 요일
	Q 분기
	AM 오전오후
	(HH, HH24) 시
	MI 분
	SS 초
	'NLS_DATE_LANGUAGE = Korean' 요일 한글


	select
			emp_no
			,emp_name
			,to_char(hire_date, 'YYYY-MM-DD' )
	from
			employee;

	● 입사일(년-월-일-시-분-초) 검색하면?
	to_char(hire_date, 'YYYY-MM-DD HH:MI:SS')

	● 시간 오전, 오후 구분(AM, HH24) 사용
	to_char(hire_date, 'YYYY-MM-DD AM HH:MI:SS')

	to_char(hire_date, 'YYYY-MM-DD HH24:MI:SS')

	● 요일(DAY, DY, D)
	to_char(hire_date, 'YYYY-MM-DD(DAY) AM HH:MI:SS')

	to_char(hire_date, 'YYYY-MM-DD(DY) AM HH:MI:SS')

	to_char(hire_date, 'YYYY-MM-DD(D) AM HH:MI:SS')

	to_char(hire_date, 'YYYY-MM-DD(DY) AM HH:MI:SS', 'NLS_DATE_LANGUAGE = Korean')

	● 분기 (Q)
	to_char(hire_date, 'YYYY-MM-DD(DY) Q AM HH:MI:SS', 'NLS_DATE_LANGUAGE = Korean')


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<49-2> employee 테이블에서 직원번호, 직원명, 입사일(x년-x월-x일(요일) x분기 시분초) 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■			select
			emp_no
			,emp_name
			,
			to_char(hire_date,'YYYY')||'년-'
			||to_char(hire_date,'MM')||'월-'
			||to_char(hire_date,'DD')||'일'
			||to_char(hire_date,'(DY) ','NLS_DATE_LANGUAGE = Korean')
			||to_char(hire_date,'Q')||'분기 '
			||to_char(hire_date,'HH')||'시 '
			||to_char(hire_date,'MI')||'분 '
			||to_char(hire_date,'SS')||'초'
	from
			employee;

	select
			emp_no
			,emp_name
			,to_char(hire_date, 'YYYY"년"MM"월"DD"일"(DY) Q"분기" AM HH"시"MI"분"SS"초"', 'NLS_DATE_LANGUAGE = Korean')
	from
			employee;







■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<50> employee 테이블에서 직원번호, 직원명, 나이 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● sysdate, to_char, to_number, case, substr 활용
	● to_number(숫자문자 내장된 컬럼명) => 컬럼명 안의 숫자 문자를 숫자로 변경하는 변환함수


	select
			emp_no							 -- 직원번호
			,emp_name						 -- 직원명
			,to_number						 -- 숫자형 변환함수
				(to_char(sysdate, 'yyyy'))	 -- 문자형 변환함수(문자 또는 숫자, '출력패턴')
			- to_number						 -- 숫자형 변환함수
				(case 						 -- case문을 통해
					substr(jumin_num,7,1)	 -- 주민번호 뒷자리 1번째자리 확인
						when '1' then '19'	 -- 1번째자리 1이면, 19 출력
						when '2' then '19'	 -- 1번째자리 2면, 19 출력
						else '20'			 -- 그 외 나머지 20 출력
				end || substr(jumin_num,1,2) --
				)
			+ 1 || '세'
	from
			employee;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<51> employee 테이블에서 직원번호, 직원명, 근무년차 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● 날짜데이터 연산, ceil 활용
	근무년차 = ((sysdate - 입사년월일)/365) => 날짜데이터끼리의 연산은 차이만큼의 일수(day)로 계산됨
	이후 소수점 첫째자리 올림 = ceil(~) <=> 내림 floor(~)
	java math.ceil(소수) => 소수 첫째자리를 반올림하는 math

	select
			emp_no				"직원번호"
			,emp_name			"직원명"
			,ceil((sysdate - hire_date)/365) || '년차' "근무년차"
	from
			employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<52> employee 테이블에서 직원번호, 직원명, 연령대를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● floor 활용 = 소수점 첫째자리 내림(버림)
	나이 구한 뒤 앞자리에 따라 0을 붙여서 10대 20대
	substr 쓰면 100살대 이상은 컨트롤하기 어려우니
	floor를 활용해서 0.1 곱하고 소수점 버리기!

	select
			emp_no							 "직원번호"
			,emp_name						 "직원명"
			,floor((
				to_number
					(to_char(sysdate, 'yyyy'))
				- to_number
					(case
						substr(jumin_num,7,1)
							when '1' then '19'
							when '2' then '19'
							else '20'
					end || substr(jumin_num,1,2)
					) + 1)
				*0.1) || '0대'  			 "연령대"
	from
			employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<53> employee 테이블에서 직원번호, 직원명, 100일잔치(년-월-일) 날짜를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● to_date, substr, ||(연결연산자) 활용
	날짜형 자료에 숫자를 더하면 자동으로 날짜로 계산해준다.
		날짜1 - 날짜2 = 날짜1과 날짜2의 차이를 일 수로 리턴
		날짜 +- 숫자 = 날짜에 정수만큼의 일 수를 연산한 날짜를 리턴
		날짜+날짜 = 그런 기능은 없다.

	select
			emp_no					"직원번호"
			,emp_name				"직원명"
			,to_char(							--문자(아래 날짜를 감쌈)
				to_date(						--날짜(아래 case문을 감쌈)
						case
							substr(jumin_num,7,1)
								when '1' then '19'
								when '2' then '19'
								else '20'
							end || substr(jumin_num,1,6), 'yyyymmdd'
						)
						+99, 'yyyy-mm-dd (DY)'
						, 'NLS_DATE_LANGUAGE=Korean'
					)		"100일잔치일"
	from
			employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<54> employee 테이블에서 직원번호, 직원명, 현재나이, 입사당일나이를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● 오늘날짜에서 출생년도를 빼면 = 나이
	● 입사날짜에서 출생년도를 빼면 = 입사 당시의 나이

	select
			emp_no
			,emp_name
			,to_number
				(to_char(sysdate, 'yyyy'))
			- to_number
				(case
					substr(jumin_num,7,1)
						when '1' then '19'
						when '2' then '19'
						else '20'
				end || substr(jumin_num,1,2)
				)
			+ 1 || '세'						"현재나이"

			,to_number
				(to_char(hire_date, 'yyyy'))
			- to_number
				(case
					substr(jumin_num,7,1)
						when '1' then '19'
						when '2' then '19'
						else '20'
				end || substr(jumin_num,1,2)
				)
			+ 1 || '세'						"입사당일나이"
	from
			employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<55> employee 테이블에서 직원번호, 직원명, 주민번호, 다가올생일날(년-월-일), 생일D-day 를 검색해서 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	다가올생일 => case 구문

	올해 생일날짜 - 지금 날짜 => 양수면 생일이 안지남
	올해 생일날짜 - 지금 날짜 => 음수면 생일이 지남




	● 내가 만든거
	select
			emp_no
			,emp_name
			,jumin_num
            ,case
				when to_date( substr(jumin_num,3,4),'MM-DD') - sysdate < 0
				then to_char(to_date( substr(jumin_num,3,4),'MM-DD') +365, 'YYYY-MM-DD')
				else to_char(to_date( substr(jumin_num,3,4),'MM-DD'), 'YYYY-MM-DD')
			end	    "다가오는 생일날"

			,floor(
					(
					case
                            when to_date(substr(jumin_num,3,4),'MM-DD')-sysdate < 0
                            then to_date(substr(jumin_num,3,4),'MM-DD')-sysdate +365
                            else to_date(substr(jumin_num,3,4),'MM-DD')-sysdate
                        end
					)
			)		"생일 D-Day"
    from
            employee;

	● 수업 때 만든거
	  다가올 생일날 => 올해생일 - 오늘날짜 => 양수면 생일이 안지남

	select
			emp_no
			,emp_name
			,jumin_num
            ,
			--다가올 생일날 (올해생일 년월일 - 지금 년월일)
			to_char(
			case
				when
						to_date(
							to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
							, 'YYYYMMDD'
						)
						-
						sysdate
						>= 0
				then
					--올해 생일을 년-월-일로 리턴하는 식
						to_date(
							to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
							, 'YYYYMMDD'
						)
				else
					--내년 생일을 년-월-일로 리턴하는 식, 올해 년도를 to_number해서 숫자로 만든 뒤 1을 더함
						to_date(
							to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
							, 'YYYYMMDD'
						)
			end, 'YYYY-MM-DD') "다가올 생일날"
			,
			--생일까지 남은 일수 (생일 년월일 - 지금 년월일)
			case
				when
						to_date(
							to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
							, 'YYYYMMDD'
						)
						-
						sysdate
						>= 0
				then
					floor(
						to_date(
							to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
							, 'YYYYMMDD'
						)
						-
						sysdate)
				else
					floor(
						to_date(
							to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
							, 'YYYYMMDD'
						)
						-
						sysdate)
				end	"생일까지 남은 일수"



	from
			employee

	order by 5 asc;





생일
substr(jumin_num,3,4)
다가올 생일
D-day
















select
	emp_no
	,emp_name
	,jumin_num
	,
	--다가올 생일날 (올해생일 년월일 - 지금 년월일)
	to_char(
		case
		when
			to_date(
				to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
				, 'YYYYMMDD'
			)
			-
			sysdate
			>= 0
		then
			to_date(
				to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
				, 'YYYYMMDD'
			)
		else
			to_date(
				to_number(to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
				, 'YYYYMMDD'
			)
		end
		, 'YYYY-MM-DD'
	)                                       "다가올 생일날"
	,
	--생일까지 남은 일수 (생일 년월일 - 지금 년월일)
	case
		when
			to_date(
				to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
				, 'YYYYMMDD'
			)
			-
			sysdate
			>= 0
		then
			floor(
				to_date(
					to_char(sysdate,'YYYY')||substr(jumin_num,3,4)
					, 'YYYYMMDD'
				)
				-
				sysdate
			)
		else
			floor(
				to_date(
					to_char(sysdate,'YYYY'))+1||substr(jumin_num,3,4)
					, 'YYYYMMDD'
				)
				-
				sysdate
			)
	end	"생일까지 남은 일수"



from
	employee
order by
	5 asc;






■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<56> employee 테이블에서 직원번호, 직원명, 직급, 연봉(xxx,xxx,xxx만원)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	● number를 to_char하는 경우, 9로 입력하면 남은 길이는 출력안됨
	● number를 to_char하는 경우, 0으로 입력하면 남은 길이는 0으로 출력됨
		=> 999,099,999 => 001,234

	select
			emp_no		"직원번호"
			,emp_name	"직원명"
			,jikup		"직급"
			,to_char(salary, '999,999,999')
			||'만원' "연봉"
	from
			employee;

	to_char(salary, '999,999,999')||'만원'
	● salary 컬럼 안의 숫자를 3자리 마다 끊어서 ,를 삽입하고 문자로 리턴
		만약 각 9자리에 대응하는 숫자 없으면 화면에 출력이 안된다

	to_char(salary, '999,999,999')||'만원'
	● salary 컬럼 안의 숫자를 3자리 마다 끊어서 ,를 삽입하고 문자로 리턴
		맨 앞에 0이 있으면 그 자리가 비어있는 경우, 0으로 대체된다.
		0자리 이후 오른쪽으로 비어있는 숫자들은 0으로 다 대체된다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<57> employee 테이블에서 수요일에 태어난 직원을 검색하여 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select * from employee
	where
		to_char(
			to_date(
				decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6)
				, 'YYYYMMDD'
			)
			,'DAY'
			,'nls_date_language=Korean'
		)
		= '수요일'
	---------------------------------------------
	select * from employee
	where
		to_char(
			to_date(
				decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6)
				, 'YYYYMMDD'
			)
			,'DY'
			,'nls_date_language=Korean'
		)
		= '수'
	---------------------------------------------
	select * from employee
	where
		to_char(
			to_date(
				decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6)
				, 'YYYYMMDD'
			)
			,'D'
		)
		= '4'
	---------------------------------------------






















--비교컬럼   비교연산자 비교값
--수요일 구하는 컬럼 = '수요일';

-- 생년월일

    to_date(
            case
                when substr(jumin_num,7,1)='1' then '19'
                when substr(jumin_num,7,1)='2' then '19'
                else '20'
            end||substr(jumin_num,1,6), 'YYMMDD')

-- 요일 구하는 컬럼
-- 생일컬럼 + to_char 요일 들어간 형식 부여
    to_char(
            to_date(
                case
                    when substr(jumin_num,7,1)='1' then '19'
                    when substr(jumin_num,7,1)='2' then '19'
                    else '20'
                end
                ||substr(jumin_num,1,6), 'YYMMDD'
                )
                ,'YYMMDD(DAY)','nls_date_language=Korean'
            )

-- where 사용해서 수요일 검색
	select * from employee
        where substr(to_char(
            to_date(
                case
                    when substr(jumin_num,7,1)='1' then '19'
                    when substr(jumin_num,7,1)='2' then '19'
                    else '20'
                end
                ||substr(jumin_num,1,6), 'YYYYMMDD'
                )
                ,'YYYYMMDD(DAY)','nls_date_language=Korean'
            ),10,3) = '수요일';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<58> employee 테이블에서 70년대  생 남자 직원을 검색하여 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select * from employee
	where
		substr(jumin_num,1,1)='7'
		and
		(substr(jumin_num,7,1)='1' or substr(jumin_num,7,1)='3')
	---------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<59> employee 테이블에서 1960년대, 1970년대 출생자중 남자만 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	where
		(substr(jumin_num,1,1)='6' or substr(jumin_num,1,1)='7')
		and
		(substr(jumin_num,7,1)='1' or substr(jumin_num,7,1)='3')


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<60> employee 테이블에서 오래 근무한 직원이 먼저 나오게 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	order by
		(sysdate-hire_date)
		desc;
	------------------------------------------
	sysdate-hire_date   => 지금날짜-입사일.   날짜에서 날짜를 빼면 차이만큼 일수를 리턴한다


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<61> employee 테이블에서
     직원번호, 직원명, 근무일수, 근무개월수, 입사후5개월후날짜(년-월-일), 입사한달의마지막날짜(년-월-일)
									입사한날짜기준돌아오는일요일날짜(년-월-일)
     검색하면?
     단, 근무일수는 소수 2자리에서 반올림하삼!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		emp_no                                             "직원번호"
		,emp_name                                          "직원명"
		,round(sysdate-hire_date,1)                        "근무일수"
		,months_between(sysdate,hire_date)                 "근무개월수"
		,to_char(add_months(hire_date,5),'YYYY-MM-DD')     "입사후5개월후날짜"
		,to_char(last_day(hire_date),'YYYY-MM-DD')         "입사한달의마지막날짜"
		,to_char(next_day(hire_date,1),'YYYY-MM-DD')       "입사한날짜기준돌아오는일요일날짜"
	from
		employee

	******************************************************
	날짜 함수 정리( 리턴값의 자료형을 조심하자)
	******************************************************
		months_between(날짜1,날짜2)  => 날짜1 과 날짜2 의 차이를 개월수로 리턴하기
		------------------------------------------
		add_months(날짜,개월수)      => 날짜에  개월수 만큼 더한 날의 날짜를 리턴하기
		------------------------------------------
		last_day(날짜)               => 날짜가 속한 달의 마지막 날짜를 리턴하기
		------------------------------------------
		next_day(날짜,요일정수)      => 날짜 기준으로 돌아오는 요일의  날짜를 리턴하기
						요일 정수는 1~7(일~토)
		------------------------------------------
		날짜1-날짜2                 => 날짜1 과 날짜2 의 차이를 일수로 리턴하기
		------------------------------------------
		날짜+정수                   => 날짜에다 정수만큼의 일수를 더한 만큼의 날의 날짜를 리턴하기
		------------------------------------------
		날짜-정수                   => 날짜에다 정수만큼의 일수를 뺀 만큼의 날의 날짜를 리턴하기
	******************************************************

	------------------------------------------
	round(숫자저장컬러명,반올림한후보여지는소수자리수) => round(sysdate-hire_date,1)
	                                                      소수2자리에서반올림한 결과 리턴
	------------------------------------------
	trunc(숫자저장컬러명,버린후보여지는소수자리수) => trunc(sysdate-hire_date,1)
	                                                   소수2자리 이후는 모두 버리고 리턴
	------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<62> employee 테이블에서 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where jikup = '과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<63> employee 테이블에서 직급이 과장인 아닌 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where jikup != '과장';
	select * from employee where jikup <> '과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<64> employee 테이블에서 부서번호가 10번 이고 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where dep_no=10 and jikup = '과장'

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<65> employee 테이블에서 직급이 과장 또는 부장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where jikup='과장' or jikup='부장';
	select * from employee where jikup in('과장', '부장');
	select * from employee where jikup = any('과장', '부장');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<66> employee 테이블에서 10번, 20번 부서 중에 직급이 과장인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where (dep_no=10 or dep_no=20) and  jikup = '과장';
	select * from employee where dep_no in(10,20) and  jikup = '과장';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<67> customer 테이블에서 담당직원이 없는 고객을 검색하면??
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from customer where emp_no is null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<68> customer 테이블에서 담당직원이 있는 고객을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from customer where emp_no is not null;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<69> customer 테이블에서 담당직원 번호가 9번이 아닌 고객을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from customer where emp_no!=9 or emp_no is null ;
	----------------------------------------------------
	<주의>emp_no is null 조건도 붙이는 이유는 emp_no가 NULL 일 경우
	      emp_no!=9 조건에 포함되지 않기 때문이다.
	      즉 NULL 은 is null 또는 is not null 연산자에 의해서만 검색된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<70> employee 테이블에서 연봉이 3000만원~4000 만원사이인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where   salary >= 3000 and salary <= 4000;
	select * from employee where salary between  3000 and 4000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<71> employee 테이블에서 연봉이 3000만원 이상~4000 만원 미만 사이인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where   salary >= 3000 and salary < 4000;
	select * from employee where (salary between  3000 and 4000)  and  salary!=4000;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<72> employee 테이블에서 연봉을 5% 인상했다고 가정하고 3000 이상인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary*1.05>= 3000

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<73> employee 테이블에서 입사일이 '1995-1-1' 이상인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where hire_date>=to_date('1995-1-1', 'YYYY-MM-DD');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<74> employee 테이블에서 입사일이 1990년~1999년 사이인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------
	select * from employee
	where
		hire_date>=to_date('1990-1-1','YYYY-MM-DD')
		and
		hire_date<to_date('2000-1-1','YYYY-MM-DD');
	--------------------------------------------------
	select * from employee where
			to_number( to_char(hire_date, 'yyyy') ) between 1990 and 1999;
	--------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<75> employee 테이블에서 부서번호가 10번 또는 30번인 직원 중에 연봉이 3000 미만이고
     입사일이 '1996-01-01' 미만 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where
			(dep_no = 10 or dep_no = 30)
			and salary<3000
			and hire_date<to_date('1996-01-01','YYYY-MM-DD');
	--------------------------------------------------
	select * from employee where
			dep_no in(10,30)
			and salary<3000
			and hire_date<to_date('1996-01-01','YYYY-MM-DD');
	--------------------------------------------------
	select * from employee where
			dep_no = any(10,30)
			and salary<3000
			and hire_date<to_date('1996-01-01','YYYY-MM-DD');

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<76> emploemployee 테이블에서 성이 김씨인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where substr(emp_name,1,1)='김';
	select * from employee where emp_name  like '김%';
	----------------------------------------------
	where 컬럼명 like '패턴문자열'  => 컬럼명 안의 데이터가 패턴문자열을 갖고 있으면 그 행을 검색하라
	----------------------------------------------
	where emp_name  like '김%'
	----------------------------------------------
		=> 김이 첫글자고 두번째는 무엇이 와도 좋고 길이에 제한없는 문자패턴을 가진 행을 골라라
		=> 문자패턴 안의 %  는 무엇이 와도 좋고 길이에 제한없음의 의미이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<77> emploemployee 테이블에서 성이 황씨인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------------------
	select * from employee where
		substr(emp_name,1,1)='황' and substr(emp_name,1,2)<>'황보';
	----------------------------------------------
	select * from employee where
		emp_name  like '황%' and emp_name not like '황보%'
	----------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<78> employee 테이블에서 이름이 2자인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where length(emp_name)=2;
	----------------------------------------------
	length(컬럼명)  => 컬럼명 안의 문자데이터의 길이를 0이상의 정수로 리턴해주는 함수



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<79> emploemployee 테이블에서 이름이 김으로 끝나는 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where emp_name  like '%김';
	select * from employee where substr( emp_name, length(emp_name) , 1 )='김'

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<80> employee 테이블에서 성이 김씨이고 3글자인 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where substr(emp_name,1,1)='김' and length(emp_name)=3;
	select * from employee where emp_name  like '김%'  and length(emp_name)=3;
	select * from employee where  emp_name like '김__';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<81> emploemployee 테이블에서 이름에 김이란 문자를 가진 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where emp_name  like '%김%';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<82> employee 테이블에서 성이 김씨가 아닌 직원 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where emp_name not like '김%';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<83> employee 테이블에서 이름 중간에만 김이 들어간 직원을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	where
		emp_name like '%김%'
		and emp_name not like '김%'
		and emp_name not like '%김';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<84> employee 테이블에서 여자 직원을 검색하라.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------
	select * from employee where
		substr(jumin_num,7,1)='2'  or  substr(jumin_num,7,1)='4';
	-----------------------------------------------------
	select * from employee where
		substr(jumin_num,7,1) in('2','4');
	-----------------------------------------------------
	select * from employee where
		jumin_num like '______2%'  or  jumin_num like '______4%';
	-----------------------------------------------------
	select * from employee where
		jumin_num not like '______1%'  and  jumin_num not like '______3%';
	-----------------------------------------------------

	-----------------------------------------------------
	만약 주민번호 중간에 - 가 있다면 아래 처럼해도 된다.
	-----------------------------------------------------
	select * from employee where
		jumin_num like '%-2%'  or  jumin_num like '%-4%';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<85> employee 테이블에서 1960년대, 1970년대 출생자중 남자만 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-----------------------------------------------------
	select * from employee where
	(substr(jumin_num,1,1)='6' or substr(jumin_num,1,1)='7') and substr(jumin_num,7,1)='1';
	-----------------------------------------------------
	select * from employee where
		substr(jumin_num,1,1) in('6','7') and substr(jumin_num,7,1)='1';
	-----------------------------------------------------
	select * from employee where
		jumin_num like '6_____1%' or jumin_num like '7_____1%';



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<86> 기타 함수 정리하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	
-----------------------------------
숫자함수
-----------------------------------
	-------------
	abs(n)
	-------------
		▶ 숫자 n의 절대값을 반환
	-------------
	floor(n)
	-------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 작으면서
			제일 가까운 정수를 반환.
		▶ 좌표계에서 쿵 찍어서 왼쪽 정수값
	-------------
	ceil(n)
	-------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 크면서
			제일 가까운 정수를 반환.
		▶ 좌표계에서 쿵 찍어서 오른쪽 정수값
	-------------
	round(n,m)
	-------------
		▶ 숫자 n에서 소수 m+1 자리에서 반올림한 수 리턴. 
	-------------
	trunc(n,m)
	-------------
		▶ 숫자 n에서 소수 m+1 자리부터 버림
	-------------
	sign(n)
	-------------
		▶ n>0 이면 1, n<0 이면 -1, n=0 이면 0을 반환
	-------------
	mod(n,m)
	-------------
		▶ n/m 후 나머지 값을 반환.    mod(5,2)
	-------------
	power(n,m)
	-------------
		▶ n의 m승을 반환.    power(5,2)



-----------------------------------
문자함수
-----------------------------------
	-------------
	chr(n)
	-------------
		▶ 정수 n을 ASCII(아스키) 문자기호로 리턴한다

	-------------
	uppper(s)
	-------------
		▶ 문자열 s를 대문자로 변환시켜 리턴한다

	-------------
	lower(s)
	-------------
		▶ 문자열 s를 소문자로 변환시켜 리턴한다

	-------------
	length(s)
	-------------
		▶ 문자열 s의 길이를 리턴한다

	-------------
	substr(s, n1, n2)
	-------------
		▶ 문자열 s에서 n1번째 자리부터 n2개 까지의 문자를 리턴한다
		▶ n2 생략 시 마지막까지 문자를 리턴한다
		▶ n1이 0일 경우, 1로 바꿔 실행된다
		▶ 자리수는 n>0 경우 왼쪽부터, n1<0 경우 오른쪽부터 셈한다
		-------------
		select substr( 'You are not alone', 9, 3 ) from dual;
		select substr( 'You are not alone', 5) from dual;
		------------
		select substr( 'You are not alone', 0, 5 ) from dual;
		select substr( 'You are not alone', -5, 2 ) from dual;
		select substr( 'You are not alone', 5, 0 ) from dual;
	-------------
	trim(s)
	-------------
		▶ 문자열 s1의 맨 좌우측의 공백을 제거하여 리턴한다
			제거 후 또 있으면 계속 제거 후 리턴한다
	-------------
	replace( s1, s2, s3 ) ****
	-------------
		-------------------------------
		▶문자열 s1에서 s2를 s3로 수정해서 리턴한다.
		▶<예> select replace(addr, '서울특별시','서울시')  from employee
		-------------------------------
		select replace( 'You are not alone', 'You', 'We' ) from dual;
		select replace( 'You are not alone', 'not' ) from dual;
		select replace( 'You are not alone', 'not', '' ) from dual;
		-------------------------------
		select translate( 'You are not alone', 'You', 'We' ) from dual;
	-------------
	initcap( s )
	-------------
		▶문자열 s에서 각 단어의 첫 문자만 대문자로 변환하고 나머지는
		  모두 소문자로 리턴한다.
		▶select  initcap( 'abc def' ) from dual;
	-------------
	lpad( s1, n, s2 )
	-------------
		▶n 자리 만큼 확보하고 s1을 오른쪽 정렬 후 왼쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.
		▶select lpad( 'abc', 7, ' ' ) from dual;
	-------------
	rpad( s1, n, s2 )
	-------------
		▶n 자리 만큼 확보하고 s1을 왼쪽 정렬 후 오른쪽에 생긴 빈 공백에
		  문자열 s2를 채워 리턴한다.
		▶select rpad( 'abc', 7, '#' ) from dual;
	-------------
	instr( s1, s2, n1, n2 )  ***
	-------------
		▶( s1:타겟문자, s2:찾을문자,  n1:검색시작위치, n2:몇번째에서 )
		<주의>오라클에서 위치를 따질 때 시작은 0이 아니라 1이다.
		▶문자열 s1 에서 문자열 s2 가 있는 위치 반환. (자바의 indexOf(~) 와 비슷한 기능)
		select
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la' ),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1, 2),
			instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 12, 2)
		from dual;








■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<87> join(조인) 이 뭡니까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	▶2개 이상의 테이블로 부터 연관성 있는 [컬럼]을 복사해서 횡으로 붙이는 작업을 말한다.
	▶예> 아래 직원번호와 직원명은 employee 테이블 소속이고, 소속부서명 은 dept 테이블 소속이다
		----------------------------------------
		 직원번호     직원명     소속부서명
		----------------------------------------
		   1           홍길동      총무부

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<88> join(조인) 의 종류?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------
	inner join
	------------------------------------
		▶조인 조건에 에 맞는 행만 포함하는 조인. 대부분이 이 조인이다. (=내부조인이러고도 한다).
	------------------------------------
	outer join
	------------------------------------
		▶조인 조건에 만족하지 못한 행도 출력하는 조인이다. 쪼까 어렵다. 시험문제 타겟..
	------------------------------------
	self join
	------------------------------------
		▶1개의 테이블을 2개 이상으로 보고 하는 조인이다. 쪼까 어렵다
	------------------------------------
	cross join
	------------------------------------
		▶2개 이상 테이블에서 각각의 행이 모두 연결되는 조인이다. 연결 조건이 생략된다.
		▶잘 사용되지 않는 조인이다.



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<89> join(조인)에는 ANSI 조인형식과 오라클 조인이 있다는데 뭡까?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------
	▶ANSI 조인
	------------------------------------
		모든 DB 업체에서 공용으로 사용되는 조인이다.
	------------------------------------
	▶오라클 조인
	------------------------------------
		오라클에서만 사용되는 조인이다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<90> 직원번호, 직원명, 소속부서명 검색?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	▶<주의>직원번호와 직원명은 employee 테이블 소속이고, 소속부서명 은 dept 테이블 소속이다
	▶<주의>허걱! 이거 단순한 select 가 아닌 2개 테이블로 부터 연관성 있는
	              [컬럼]을 복사해서 횡으로 붙이는 작업 즉 조인이 필요하다.
	------------------------------------
	<오라클 inner 조인>테이블에 별칭을 주지 않고 조인한 것
	------------------------------------
	select
		employee.emp_no
		, employee.emp_name
		, dept.dep_name
	from
		employee , dept
	where
		employee.dep_no=dept.dep_no
	------------------------------------
	<오라클 inner 조인>테이블에 별칭을 주고 조인한 것
	------------------------------------
	select
		e.emp_no
		, e.emp_name
		, d.dep_name
	from
		employee e , dept d
	where
		e.dep_no=d.dep_no
	------------------------------------
	<ANSI inner 조인>
	------------------------------------
	select
		e.emp_no
		, e.emp_name
		, d.dep_name
	from
		employee e inner join dept d
	on
		e.dep_no=d.dep_no
	------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<91> 고객명, 고객전화번호, 담당직원명, 담당직원직급 을 출력하면? <조건>담당직원이 있는 고객만 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------
	<주의>담당직원이 있는 고객만 나와야하므로, 즉 조건에 맞는 행만 나와야하므로 inner 조인이다.
	------------------------------------
	오라클 조인
	------------------------------------
	select
		c.cus_name    "고객명"
		, c.tel_num   "고객전화번호"
		, e.emp_name  "담당직원명"
		, e.jikup     "담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no
	------------------------------------
	ANSI 조인
	------------------------------------
	select
		c.cus_name    "고객명"
		, c.tel_num   "고객전화번호"
		, e.emp_name  "담당직원명"
		, e.jikup     "담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no=e.emp_no
	------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<92> 고객명, 고객전화번호, 담당직원명, 담당직원직급  을 출력하면? <조건>10번부서의 담당직원이 있는 고객만 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------
	오라클 조인
	------------------------------------
	select
		c.cus_name    "고객명"
		, c.tel_num   "고객전화번호"
		, e.emp_name  "담당직원명"
		, e.jikup     "담당직원직급"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no and e.dep_no=10
	------------------------------------
		<주의>오라클 조인에서 where 절에 조인 조건과 행을 골라내는 조건이 같이 나올수 있다.
		      and 로 연결하면된다.
	------------------------------------
	ANSI 조인
	------------------------------------
	select
		c.cus_name    "고객명"
		, c.tel_num   "고객전화번호"
		, e.emp_name  "담당직원명"
		, e.jikup     "담당직원직급"
	from
		customer c inner join employee e
	on
		c.emp_no=e.emp_no
	where
		e.dep_no=10
	------------------------------------
		<주의>ANSI 조인에서 on 절에 조인 조건을 쓰고, where 절에 행을 골라내는 조건을 쓴다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<93> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>연봉이 3000만원 이상인 담당직원이 있는 고객만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------
	오라클 조인
	------------------------------------
	select 
		c.cus_name "고객명"
		, c.tel_num "고객전화번호"
		, e.emp_name "담당직원명"
		, e.jikup "담당직원직급"
	from 
		customer c, employee e
	where 
		c.emp_no=e.emp_no and e.salary>=3000;
	------------------------------------
	ANSI 조인
	------------------------------------
	select 
		c.cus_name "고객명"
		, c.tel_num "고객전화번호"
		, e.emp_name "담당직원명"
		, e.jikup "담당직원직급"
	from 
		customer c inner join employee e
	on 
		c.emp_no=e.emp_no;
	where 
		e.salary>=3000;
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<94> [직원명], [직원직급], [직원부서명], [담당고객명], [고객전화]를 출력하면? <조건>직원 이름 오름차순 정렬
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------
	오라클 조인
	------------------------------------
	select 
		e.emp_name     "직원명"
		, e.jikup      "직원직급"
		, d.dep_name   "직원부서명"
		, c.cus_name   "담당고객명"
		, c.tel_num    "고객전화번호"
	from 
		employee e, dept d, customer c 
	where 
		e.dep_no=d.dep_no and  e.emp_no=c.emp_no
	order by 
		e.emp_name asc;
	------------------------------------
	ANSI 조인
	------------------------------------
	select 
		e.emp_name     "직원명"
		, e.jikup      "직원직급"
		, d.dep_name   "직원부서명"
		, c.cus_name   "담당고객명"
		, c.tel_num    "고객전화번호"
	from 
		(employee e inner join dept d  on  e.dep_no=d.dep_no) 
			inner join customer c on c.emp_no=e.emp_no 
	order by 
		e.emp_name asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<95> 직원명, 직원직급, 소속부서명, 연봉등급 을 출력하면? 연봉등급 오름차순, 직급높은순서 오름차순, 나이높은순서 내림 유지 요망
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------
	오라클 조인
	------------------------------------
	select 
		e.emp_name, e.jikup, d.dep_name, s.sal_grade_no
	from 
		employee e, dept d, salary_grade s
	where
		e.dep_no=d.dep_no and (e.salary>=s.min_salary and e.salary<=s.max_salary)
	order by
		 s.sal_grade_no asc
		, decode(e.jikup,'사장',1,'부장',2,'과장',3,'대리',4,'주임',5,6)  asc
		, case when substr(e.jumin_num, 7,1) in('1','2') then '19' else '20' end  || substr(e.jumin_num, 1,6) asc
	------------------------------------
	select 
		e.emp_name, e.jikup, d.dep_name, s.sal_grade_no
	from 
		employee e, dept d, salary_grade s
	where
		e.dep_no=d.dep_no and (e.salary between s.min_salary and s.max_salary)
	order by
		 s.sal_grade_no asc
		, decode(e.jikup,'사장',1,'부장',2,'과장',3,'대리',4,'주임',5,6)  asc
		, case when substr(e.jumin_num, 7,1) in('1','2') then '19' else '20' end  || substr(e.jumin_num, 1,6) asc
	------------------------------------
	ANSI 조인
	------------------------------------
	select 
		e.emp_name, e.jikup, d.dep_name, s.sal_grade_no
	from 
		(dept d inner join employee e on d.dep_no=e.dep_no) inner join 
			salary_grade s on (e.salary between s.min_salary and s.max_salary)
	order by
		 s.sal_grade_no asc
		, decode(e.jikup,'사장',1,'부장',2,'과장',3,'대리',4,'주임',5,6)  asc
		, case when substr(e.jumin_num, 7,1) in('1','2') then '19' else '20' end  || substr(e.jumin_num, 1,6) asc
	------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<96> 부하직원명, 부하직원직급, 직속상관명, 직속상관직급을 출력하면? <조건>상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
		e1.emp_name    "직원명"
		, e1.jikup     "직원직급"
		, e2.emp_name  "직속상관명"
		, e2.jikup     "직속상관직급"
	from 
		employee e1, employee e2
	where 
		e1.mgr_emp_no=e2.emp_no

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<97> 직속상관명, 직속상관직급, 부하직원명, 부하직원직급 을 출력하면? <조건>상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------
	select 
		e1.emp_name    "직속상관명"
		, e1.jikup     "직속상관직급"
		, e2.emp_name  "부하직원명"
		, e2.jikup     "부하직원직급"
	from 
		employee e1, employee e2
	where 
		e1.emp_no=e2.mgr_emp_no
	-------------------------------------------
	select
			e1.emp_name		"직속상관명"
			,e1.jikup		"직속상관직급"
			,e2.emp_name	        "부하직원명"
			,e2.jikup		"부하직원직급"
	from
			employee e1 inner join employee e2
	on
			e1.emp_no = e2.mgr_emp_no;
	-------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<98> 직원명, 직원직급,  소속부서명, 연봉등급, 직속상관명, 직속상관직급, 담당고객명 을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------------------------
	select 
		e1.emp_name
		, e1.jikup
		, d.dep_name
		, s.sal_grade_no
		, e2.emp_name
		, e2.jikup
		, c.cus_name
	from 
		employee e1, dept d, salary_grade s, employee e2, customer c
	where 
		e1.dep_no=d.dep_no 
		and (e1.salary>=s.min_sal and e1.salary<=s.max_sal) 
		and e2.emp_no=e1.mgr_emp_no 
		and e1.emp_no=c.emp_no;
	---------------------------------------------------------------
	select
		e.emp_name         "직원명",
		e.jikup            "직원직급",
		d.dep_name         "소속부서명",
		s.sal_grade_no     "연봉등급",
		e2.emp_name        "직속상관명",
		e2.jikup           "직속상관직급",
		c.cus_name          "고객명"
	from
		(((employee e inner join dept d
		on	e.dep_no = d.dep_no) inner join salary_grade s
		on	e.salary between s.min_salary and s.max_salary) inner join employee e2
		on	e.mgr_emp_no = e2.emp_no) inner join customer c
		on	c.emp_no = e.emp_no
	---------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<99> 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? <조건>담당직원이 없는 고객도 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------------------------
	<주의>담당직원이 없는 고객도 포함 하라는 얘기는 고객은 다 나오라는 말이다. 즉 outer 조인하라는 말이다.
	      outer 조인은 한쪽은 다 나오는 조인이다. 나머지는 조건에 안 맞더라도 null 달고라도 나오라는 조인이다.
	---------------------------------------------------------------
	select 
	       c.cus_name      "고객명"
	       ,c.tel_num      "고객전화번호" 
	       ,e.emp_name     "담당직원명"
	       ,e.jikup        "담당직원직급"
	       ,e.dep_no       "부서번호" 
	from 
		customer c, employee e 
	where 
		c.emp_no = e.emp_no(+)
	---------------------------------------------------------------
	▶c.emp_no = e.emp_no(+) 의미 
		(+)가 붙은 컬럼의 반대편 컬럼의 소속 테이블 행은 모두 나오고 
		(+)가 붙은 e.emp_no 컬럼의 소속 테이블 행은 조건에 맞는 게 없으면 null 이라도 달고 나오라는 뜻
		c.emp_no = e.emp_no(+)
	---------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<100> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급을 출력하면? 
     <조건>고객정보는 모두 보이고 직원정보는 10번 부서만 보일 것
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	*******************************************************
	오라클 조인
	*******************************************************
	select
		c.cus_no
		,c.cus_name
		,c.tel_num
		,e.emp_name
		,e.jikup
		,e.dep_no
	from
		customer c , employee e
	where

		c.emp_no = e.emp_no(+) and e.dep_no(+)=10
	*******************************************************
		---------------------------------------------------------------
		<주의> outer 조인에서 where 에 (+)가 붙는 놈은?
		---------------------------------------------------------------
			where 절에 다나오는 메인 테이블 소속이 아닌 모든 컬럼에 붙는다.
			심지어 행을 골라내는 조건의 컬럼도 여기에 속한다.
		---------------------------------------------------------------------
		<세끼문제>만약 e.dep_no(+) =10 을 e.dep_no=10 로 수정하면?
		---------------------------------------------------------------------
			담당직원이 10번 부서인 고객만 포함된다. 
			마치 inner 조인의 결과 처럼 보인다.
	*******************************************************
	ANSI조인
	*******************************************************
	select
		c.cus_no
		,c.cus_name
		,c.tel_num
		,e.emp_name
		,e.jikup
		,e.dep_no
	from
		customer c   left outer join   employee e
	on

		c.emp_no = e.emp_no and e.dep_no =10;
	*******************************************************
		---------------------------------------------------------------
		<주의> ANSI조인에서    left outer join 나오면 left outer join 왼쪽에 있는 테이블이 다 나오는 테이블이다.
		---------------------------------------------------------------
		<주의> ANSI조인에서    right outer join 나오면 right outer join 오른쪽에 있는 테이블이 다 나오는 테이블이다.
		---------------------------------------------------------------
		---------------------------------------------------------------------
		<세끼문제>만약 e.dep_no =10 를 따로 빼내서 where e.dep_no =10  로 추가하면?
		---------------------------------------------------------------------
			where 절이 있으면 행을 골라내므로 고객이 2명만 나온다.
			ANSI 방식의 outer 조인에서는 행을 골라내는 조건도 on 절에 들어가야한다.
			만약에 where 절을 쓰면 메인 테이블이 다 나오지 않을수 있다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<101> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 담당직원연봉등급을 출력하면? <조건>담당직원이 없는 고객도 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

	select c.cus_no              "고객번호", 
	       c.cus_name           "고객명",
	       c.tel_num             "고객전화번호", 
	       e.emp_name          "담당직원명", 
	       e.jikup               "담당직원직급", 
	       s.sal_grade_no        "담당직원연봉등급" 
	from 
		customer c, employee e , salary_grade s 
	where 
		c.emp_no = e.emp_no(+) 
		and 
		s.min_salary(+)<=e.salary  
			and s.max_salary(+) >=e.salary
	---------------------------------------------------------------------
	<주의> employee 입장에서 메인 테이블은 customer 이고 , salary_grade 테이블 입장에서 메인 테이블은 employee 이다.
	       메인에 딸려나오는 다른 테이블의 컬럼에 (+)를 붙이면된다.
	---------------------------------------------------------------------
	<주의>아래 처럼은 안된다. 즉 (+)를 양쪽에 붙일수는 없다.
		s.min_salary(+)<=e.salary(+)   and s.max_salary(+) >=e.salary(+)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<102> 고객번호, 고객명, 고객주민번호 출력하라. 단  연봉이 3000 이상인 담당직원이 담당한 고객 이어야한다
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
    select c.cus_no              "고객번호", 
           c.cus_name           "고객명",
           c.tel_num             "고객전화번호"
    from 
        customer c, employee e
    where 
       e.salary>=3000 and e.emp_no=c.emp_no 

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<103> 고객번호, 고객명, 고객주민번호 출력하라. 단  40 살 이상인 담당직원이 담당한 고객 이어야한다
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------------------
	select
		c.cus_no
		,c.cus_name
		,c.jumin_num
	from
		customer c , employee e
	where 
	    c.emp_no=e.emp_no          
	    and 
		(
			extract(year from sysdate)
			-
			extract(
				year from
				to_date(
					decode(substr(e.jumin_num,7,1), '1', '19', '2', '19', '20')
						||substr(e.jumin_num,1,6)     
					,'YYYYMMDD'
				)
			)+1
		)>=40
	------------------------------------------------------------------
	<주의>위는 코딩 상 분명히 조인 이지만 출력되는 컬럼은 한개의 테이블에서 나오는 컬럼들이다.
	       위 코딩은 조인이 출력  목적이 아닌 조건 목적으로 사용된 것이다.
	------------------------------------------------------------------
	<세끼문제>10부서 또는 30 번 부서 직원이 담당하는 고객을 검색하면?
	------------------------------------------------------------------
		select 
			c.cus_no
			,c.cus_name
		from 
			customer c, employee e
		where
			 c.emp_no=e.emp_no
			 and
			 e.dep_no  in(10,30)
	------------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<104> 고객번호, 고객명, 담당직원번호, 담당직원명, 담당직원소속부서명, 담당직원연봉등급, 
				담당직원직속상관명, 담당직원직속상관직급, 직속상관연봉등급   출력하라.
	 단, 고객은 다 나와야하고 null은  없음  으로 표시
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
    c.cus_no "고객번호"
    , c.cus_name "고객명"
    , nvl(to_char(e1.emp_no), '없음')       "담당직원번호"
    , nvl(e1.emp_name, '없음')              "담당직원명"
    , nvl(d.dep_name, '없음')               "담당직원소속부서명"
    , nvl(to_char(s1.sal_grade_no), '없음') "담당직원연봉등급"
    , nvl(e2.emp_name, '없음')              "담당직원직속상관명"
    , nvl(e2.jikup, '없음')                 "담당직원직속상관직급"
    , nvl(to_char(s2.sal_grade_no), '없음') "직속상관연봉등급"
from customer c, employee e1, dept d, salary_grade s1, employee e2, salary_grade s2
where
    c.emp_no = e1.emp_no(+)
    and d.dep_no(+) = e1.dep_no
    and e1.mgr_emp_no = e2.emp_no(+)
    and e1.salary between s1.min_salary(+) and s1.max_salary(+)
    and e2.salary between s2.min_salary(+) and s2.max_salary(+)
order by c.cus_no asc;
-------------------------------------------------------------------------
select
    c.cus_no                                "고객번호"
    , c.cus_name                            "고객명"
    , nvl(to_char(e1.emp_no), '없음')       "담당직원번호"
    , nvl(e1.emp_name, '없음')              "담당직원명"
    , nvl(d.dep_name, '없음')               "담당직원소속부서명"
    , nvl(to_char(s1.sal_grade_no), '없음') "담당직원연봉등급"
    , nvl(e2.emp_name, '없음')              "담당직원직속상관명"
    , nvl(e2.jikup, '없음')                 "담당직원직속상관직급"
    , nvl(to_char(s2.sal_grade_no), '없음') "직속상관연봉등급"
from ((((customer c left outer join employee e1 on c.emp_no = e1.emp_no)
    left outer join dept d on e1.dep_no = d.dep_no)
    left outer join salary_grade s1 on e1.salary between s1.min_salary and s1.max_salary)
    left outer join employee e2 on e1.mgr_emp_no = e2.emp_no)
    left outer join salary_grade s2 on e2.salary between s2.min_salary and s2.max_salary
order by c.cus_no asc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<105> 직원명, 직원전화번호 와  고객명, 고객전화번호를 종으로 붙여 출력하라. 조건은 중복하지 말것.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	
	-------------------------------------
	union
	-------------------------------------
		서로 다른 테이블의 컬럼을 종으로 붙이는 작업을 말한다.
		union 규칙 
			=> 컬럼의 개수가 일치해야한다.
			=> 붙는 컬럼의 자료형이 일치해야한다.

	-------------------------------------
	select emp_name||' 직원', phone from employee
	union
	select cus_name||' 고객', tel_num from customer
	-------------------------------------
	union 만 쓰면 중복행을 제거한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<106> 직원명, 직원전화번호 와  고객명, 고객전화번호를 종으로 붙여 출력하라. 조건은 중복허락
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select emp_name, phone from employee
	union all
	select cus_name, tel_num from customer
	-------------------------------------
	union all 을 쓰면 중복행을 허락한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<107> subquery(서브쿼리)가 모조?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	-------------------------------------------------------------------------------
	select, insert, update, delete 구문 안에 들어 있는 또 다른 select 문을 말한다.
	-------------------------------------------------------------------------------
	<주의>from 절에 나오는 select 는 서브쿼리가 아니라 inline(인라인뷰)라고 부른다.
	-------------------------------------------------------------------------------
	------------------------------
	서브쿼리 사용 시 주의점
	------------------------------
		select, update, delete 안의 서브쿼리는 꼭 ( )로 묶는다.
		경우에 따라 조인 대신 서브쿼리를 써도 같은 결과를 낼 수 있다.  이때 join 보다 서브쿼리의 부하가 더 많이 걸린다.
	------------------------------
	서브쿼리 종류
	------------------------------
		---------------
		비상관쿼리(Noncorrelated Subquery)
		---------------
			[서브 쿼리]와 [외부쿼리]가 연관성이 없다. 
			[서브 쿼리] 실행 후의 결과값을 가지고 [외부 쿼리] 실행된다.
			<예> 평균 연봉 이상 받는 직원을 검색하면?
			select * from employee where salary>=(select avg(salary) from employee)

		---------------
		상관쿼리(Correlated Subquery)
		---------------
			[서브 쿼리]와 [외부쿼리]가 연관성이 있다.  
			[서브 쿼리]와 [외부쿼리]가 서로 통신하면서 쿼리가 진행된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<108> 최고 연봉을 받는 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	--------------------------------------------------
	select * from employee 		
	where salary =(select max(salary) from employee);
	--------------------------------------------------
	서브쿼리 select max(salary) from employee 가 먼저 실행되고 난후 리턴되는 최고연봉을 가지고 바깥 쿼리가 실행된다.
	위 쿼리는 비상관쿼리이다.[서브 쿼리] 실행 후의 결과값을 가지고 [외부 쿼리] 실행되기 때문이다.
	<주의> ~ where salary = max(salary); 이케하면 안된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<109> 평균 연봉 이상을 받는 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary>=(select avg(salary) from employee)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<110> 20번 부서에서 최고 연봉자 직원을 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------------------
	select * from employee 	
	where salary = (select max(salary) from employee where dep_no=20) and dep_no=20;
	------------------------------------------------------------------	
	아래 처럼 하면 문제가 바뀐다. 
	"20번 부서의 최고 연봉자와 동일한 연봉을 받는 모든 직원을 검색하라" 이렇게 바뀐다.
	------------------------------------------------------------------	
	select * from employee 	
	where salary = (select max(salary) from employee where dep_no=20);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<111> [직원명], [직급], [연봉], [전체연봉에서 차지하는 비율]을 검색하라.  
      단 [전체연봉에서 차지하는 비율]은 소수점 버림하고 %로 표현하라
      단 높은 비율이 먼저 나오게 정렬하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------------------------------------			
	select 
		emp_name    "직원명"
		, jikup     "직급"
		, salary    "연봉"
		, floor(salary/(select sum(salary) from employee)*100) ||'%'  "연봉비율"
	from 
		employee
	order by   
		salary/(select sum(salary) from employee)*100     desc
	---------------------------------------------------------------------------			
	select 
		emp_name    "직원명"
		, jikup     "직급"
		, salary    "연봉"
		, trunc(salary/(select sum(salary) from employee)*100,1) ||'%'  "연봉비율"
	from 
		employee
	order by   
		salary/(select sum(salary) from employee)*100    desc
	---------------------------------------------------------------------------	
	<주의>정렬할 때는 소수점 컨트롤을 하지 말고 소수점이 널부러지게하고 정렬해야 정확한 정렬이 된다.
	---------------------------------------------------------------------------		


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<112> 10번 부서 직원들이 관리하는 [고객번호], [고객명], [직원번호]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------------------------------------
	<1>조인 답
	---------------------------------------------------------------------------
	select 
		c.cus_no, c.cus_name, c.emp_no
	from
		customer c, employee e
	where 
		c.emp_no = e.emp_no  and  e.dep_no=10; 
	---------------------------------------------------------------------------
	<2>서브쿼리 중 비상관 쿼리 답1
	---------------------------------------------------------------------------
	select 
		cus_no, cus_name, emp_no
	from 
		customer
	where 
		emp_no in ( select emp_no from employee where dep_no=10 )
	---------------------------------------------------------------------------
		in 뒤에 n행1열의 결과가 나오는 서브쿼리가 나오면 
		n행1열의 검색 데이터가 in 뒤에 콤마(,) 로 나열된다.
	---------------------------------------------------------------------------
	<3>서브쿼리 중 비상관 쿼리 답2
	---------------------------------------------------------------------------
	select 
		cus_no, cus_name, emp_no
	from 
		customer
	where 
		emp_no= any( select emp_no from employee where dep_no=10 )
	---------------------------------------------------------------------------
	<4>서브쿼리 중 상관 쿼리 답1
	---------------------------------------------------------------------------
	select 
		c.cus_no, c.cus_name, c.emp_no  
	from 
		customer  c
	where
		(select e.dep_no from employee e where c.emp_no = e.emp_no)=10;
	---------------------------------------------------------------------------
	<5>서브쿼리 중 상관 쿼리 답2
	---------------------------------------------------------------------------
	select 
		c.cus_no, c.cus_name, c.emp_no  
	from 
		customer  c
	where
		(select count(*) from employee e where c.emp_no = e.emp_no and e.dep_no=10)>0;



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<113> 평균 연봉 이상이고 최대 연봉 미만의 [직원명], [연봉], [전체평균연봉], [전체최대연봉]을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
		emp_name "직원명"
		,  salary "연봉"
		, (select avg(salary) from employee) 전체평균연봉
		, (select max(salary) from employee) 전체최대연봉
	from 
		employee
	where
		salary>=(select avg(salary) from employee)  
		and 
		salary<(select max(salary) from employee);

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<114> 최고 연봉 직원의 [직원번호], [직원명], [부서명], [연봉]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
		e.emp_no, e.emp_name, d.dep_name,  e.salary
	from 
		dept d, employee e
	where
		d.dep_no=e.dep_no and e.salary = ( select max(salary) from employee )

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<115> 담당 고객이 2명 이상인 [직원번호], [직원명], [직급]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
		e.emp_no, e.emp_name, e.jikup
	from 
		employee e 
	where 
		(select count(*) from customer  c where e.emp_no = c.emp_no)>=2;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<116> [직원번호], [직원명], [소속부서명]을 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------------------------------------
	조인 답
	---------------------------------------------------------------------------
	select 
		e.emp_no "직원번호",  e.emp_name "직원명",  d.dep_name "부서명"
	from 
		employee e, dept d
	where 
		e.dep_no=d.dep_no;
	---------------------------------------------------------------------------
	서브쿼리 답
	---------------------------------------------------------------------------
	select 
		e.emp_no                                                            "직원번호" 
		, e.emp_name                                                        "직원명"
		, (select d.dep_name from dept d where d.dep_no=e.dep_no)           "부서명"
	from 
		employee e;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<117> [직원번호], [직원명], [연봉], [연봉 순위]를 출력하면? 단  [연봉 순위]를 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
		e1.emp_no           "직원번호" 
		, e1.emp_name       "직원명" 
		, e1.salary         "연봉" 
		, ( select  count(*)+1   from employee e2 where e2.salary>e1.salary ) "연봉순위"
	from  
		employee e1 
	order by 
		4;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<118> [직원번호], [직원명], [담당고객수]를 출력하면? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select 

	e.emp_no      "직원번호"

	, e.emp_name   "직원명"

	, (select count(*) from customer c where c.emp_no=e.emp_no) "담당고객수"

from employee e;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<119> 아래 처럼 [부서명], [부서직원수], [부서담당고객수]를 출력하면? *****
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
	    d.dep_name                                                          "부서명"
	    , (select count(*) from employee e where e.dep_no=d.dep_no)||'명'   "직원총수"
	    , (
		select 
			count(*) 
		from 
			employee e, customer c 
		where 
			e.dep_no=d.dep_no and e.emp_no=c.emp_no 

	     )||'명'        "담당총고객수"
	from 
		dept d
	order by 
		2 desc;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<120> [직원번호], [직원명], [직급], [주민번호], [직급서열순위]를  출력하면? *****
	단  직급이 같으면 나이 많은 직원이 [직급서열순위] 위이다. 그리고 [직급서열순위]를 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select   
		e1.emp_no       "직원번호"
		, e1.emp_name   "직원명"
		, e1.jikup      "직급"
		, e1.jumin_num  "주민번호", 
		, (
			select count(*)+1  from employee e2  
			where 
			decode(e2.jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6) 
				< decode(e1.jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6) 	

			or  
			(
				e2.jikup=e1.jikup and
				to_number( 
					decode( substr(e2.jumin_num,7,1),'1', '19','2', '19','20')||substr(e2.jumin_num,1,6) 
				)
				<
				to_number( 
					decode( substr(e1.jumin_num,7,1),'1', '19','2', '19','20')||substr(e1.jumin_num,1,6)
				)
			)
		)
	from 
		employee e1 
	order by 
		5;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<121>  고객번호,고객명,고객전화번호,담당직원명,담당직원직급,부서번호 를  출력하면? <조건>담당직원이 없는 고객도 포함 
        단 조인을 사용하지 말고 서브쿼리를 사용하십시요
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------------
	서브쿼리 답
	---------------------------------------------------
	select 
		c.cus_no         "고객번호"
		, c.cus_name     "고객명" 
		, c.tel_num      "고객전화번호" 
		, (select e.emp_name from employee e where c.emp_no=e.emp_no) 	  "담당직원명"
		, (select e.jikup from employee e where c.emp_no=e.emp_no)         "담당직원직급"
		, (select e.dep_no from employee e where c.emp_no=e.emp_no)      "부서번호" 
	from 
		customer c;


















	---------------------------------------------------
	조인 답(오라클 조인)
	---------------------------------------------------
	select 
	       c.cus_no     "고객번호", 
	       c.cus_name     "고객명", 
	       c.tel_num      "고객전화번호", 
	       e.emp_name   "담당직원명", ㅁ
	       e.jikup         "담당직원직급", 
	       e.dep_no      "부서번호" 
	from customer c, employee e 
	where c.emp_no = e.emp_no(+) order by 1;
	---------------------------------------------------
	조인 답(ANSI 조인)
	---------------------------------------------------
	select 
	       c.cus_no     "고객번호", 
	       c.cus_name     "고객명", 
	       c.tel_num      "고객전화번호",
	       e.emp_name   "담당직원명", 
	       e.jikup         "담당직원직급", 
	       e.dep_no      "부서번호" 
	from customer c left outer join employee e 
	       on c.emp_no = e.emp_no
	order by 1; 




■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<122>  고객번호,고객명,고객전화번호,담당직원명,담당직원직급,부서번호 를  출력하면? 
	<조건>고객정보는 모두 보이고 직원정보는 10번 부서만 보일 것
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------------
	서브쿼리 답
	---------------------------------------------------
	select 
	       c.cus_no     "고객번호", 
	       c.cus_name     "고객명", 
	       c.tel_num      "고객전화번호", 
	       (select e.emp_name from employee e where c.emp_no=e.emp_no and e.dep_no=10)    "담당직원명", 
	       (select e.jikup from employee e where c.emp_no=e.emp_no and e.dep_no=10)       "담당직원직급", 
	       (select e.dep_no from employee e where c.emp_no=e.emp_no and e.dep_no=10)      "부서번호" 
	from customer c  
	order by 1;
	---------------------------------------------------
	조인 답(오라클 조인)
	---------------------------------------------------
	select 
	       c.cus_no       "고객번호", 
	       c.cus_name     "고객명", 
	       c.tel_num      "고객전화번호", 
	       e.emp_name     "담당직원명", 
	       e.jikup        "담당직원직급", 
	       e.dep_no       "부서번호" 
	from customer c, employee e 
	where c.emp_no = e.emp_no(+) and  e.dep_no(+)=10 order by 1;
	---------------------------------------------------
	조인 답(ANSI 조인)
	---------------------------------------------------
	select 
	       c.cus_no     "고객번호", 
	       c.cus_name     "고객명", 
	       c.tel_num      "고객전화번호", 
	       e.emp_name   "담당직원명", 
	       e.jikup         "담당직원직급", 
	       e.dep_no      "부서번호" 
	from customer c left outer join employee e 
	       on c.emp_no = e.emp_no  and  e.dep_no=10
	order by 1; 



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<123>  GROUP BY 구문이 뭡니까? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	▶select 절에 있는 컬럼안의 중복 데이터를 [하나로 그룹]지어 주는 역할을 한다.
	▶주로 그룹을 지어 통계를 낼때 사용한다.
	▶GROUP BY 구문 문법은 간단하나 통계를 내는 과정에서 각종 함수가 때거지로 등장한다.
	   그러므로 GROUP BY 구문은 함수와의 싸움이다.


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<124>  부서별로 [부서번호], [급여합], [평균급여], [인원수]를 출력하면? 단 평균은 소수 2째자리에서 반올림 할 것
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	---------------------------------------------
	select
		dep_no                    "부서번호"
		, sum(salary)             "급여합"
		, round(avg(salary),1)    "평균급여"
		, count(*)                "인원수"
	from 
		employee
	group by 
		dep_no;
	---------------------------------------------
	▶select 절에 일반 컬럼과 그룹함수 컬럼이 등장하면 group by 뒤에는 반드시 그룹지을 일반 컬럼이 나와야한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<125>  직급별로 [직급], [급여합], [평균급여], [인원수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
		jikup                     "직급"
		, sum(salary)             "급여합"
		, round(avg(salary),1)    "평균급여"
		, count(*)||'명'          "인원수"  
	from 
		employee
	group by
		jikup

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<126>  부서별, 직급별, [부서번호], [직급], [급여합], [평균급여], [인원수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
		dep_no                   "부서번호"
		, jikup                  "직급"
		, sum(salary)            "급여합"
		, round(avg(salary),1)   "평균급여"
		, count(*)  "인원수" 
	from 
		employee
	group by
		dep_no, jikup

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<127> 부서별로 직급별 [부서번호], [직급], [급여합], [평균급여], [인원수]를 출력하되 인원수는 3명 이상을 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------
	select 
		dep_no                  "부서번호"
		, jikup                 "직급"
		, sum(salary)           "급여합"  
		, round(avg(salary),1)  "평균급여"
		, count(*)              "인원수" 
	from 
		employee
	group by 
		dep_no, jikup
	having
		count(*)>= 3;
	------------------------------------------------------
		group by 결과물에서 행을 골라낼 때에는 where 를 쓰지 말고 having 을 사용한다.

	------------------------------------------------------
	인라인 뷰를 사용하면 다음과 같이 문제를 풀수 있다.
	------------------------------------------------------
	select 
		*
	from
	(
		select 
			dep_no                  DEP_NO
			, jikup                 JIKUP
			, sum(salary)           TOT_SALARY
			, round(avg(salary),1)  AVG_SALARY
			, count(*)              EMP_CNT 
		from 
			employee
		group by 
			dep_no, jikup
	) 
	where
		EMP_CNT>=3
	------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<128> 부서별, 성별로  [부서번호], [성], [급여합], [평균급여], [인원수]를 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------
	select 
	    dep_no                                                                    "부서번호"
	    , case when substr( jumin_num,7,1) in('1','3')  then '남' else  '여' end  "성별"
	    , sum(salary)                                                             "급여합" 
	    , round(avg(salary),1)                                                    "평균급여" 
	    , count(*)                                                                "인원수" 
	from 
		employee
	group by
		dep_no
		,  case when substr( jumin_num,7,1) in('1','3')  then '남' else  '여' end 
	------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<129> 입사년도별로 [입사년도], [인원수]를 출력하고 년도별로 오름차순 하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------
	select 
		to_char(hire_date, 'YYYY')   "입사년도" 
		, count(*)                   "인원수" 
	from 
		employee
	group by
		to_char(hire_date, 'YYYY')
	order by 
		"입사년도" asc;
	------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<130> 부서별로 [부서번호], [평균근무년수]를 출력하면? (근무년수는 소수점 2째 자리에서 반올림할 것 )
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------
	select 
		dep_no                                                          "부서번호" 
		, round(      avg( (sysdate-hire_date)/365 ) , 1      ) ||'년'  "평균근무년수" 
	from 
		employee
	group by 
		dep_no;
	------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<131> 입사분기별로 [입사분기], [인원수] 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------
	select 
		to_char( hire_date, 'Q' )||'분기'   "입사분기" 
		, count(*)                          "인원수"
	from 
		employee
	group by 
		to_char( hire_date, 'Q' )||'분기'
	------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<132> 입사연대별, 성별로 [입사연대], [성], [연대별입사자수] 출력하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select 
		substr(  to_char( hire_date, 'YYYY' ), 1, 3  )||'0년대'      "입사연대" 
		,decode(substr( jumin_num,7,1),'1', '남', '3', '남', '여' )  "성별"  
		,count(*)                                                    "연대별입사자수"
	from employee
	group by 
		substr(  to_char( hire_date, 'YYYY' ), 1, 3  )||'0년대'
		,decode(substr( jumin_num,7,1),'1', '남', '3', '남', '여' ) 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<133> [직원명], [입사일](년-월-일 ~/4분기 한글1자리요일), [퇴직일](년-월-일) 출력하면? <조건>퇴직일은 입사 후 20년 5개월 10일 후
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
   select 
		emp_name                                                             "직원명" 
       
		,to_char( hire_date, 'YYYY-MM-DD Q' )|| '/4분기 ' || 
			to_char( hire_date, 'DAY', 'NLS_DATE_LANGUAGE = Korean')     "입사일"
		       
		,to_char(     
		    add_months(   hire_date, 5 + 20*12    )+10, 'YYYY-MM-DD'     
		)                                                                    "퇴직일"
   from employee;
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<134> 직원들이 있는 부서별로 [부서번호], [부서위치], [직원수]를 출력하면? 모든 부서 다 나오라!
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	----------------------------------------------------
	select 
		d.dep_no           "부서번호" 
		,d.loc             "부서위치"
		,count(e.emp_name) "직원수" 
	from 
		employee e, dept d
	where 
		e.dep_no(+) = d.dep_no
	group by 
		d.dep_no,  d.loc;
	----------------------------------------------------
	select 
		d.dep_no  "부서번호" 
		, d.loc    "부서위치"
		, (select count(*) from employee e where e.dep_no=d.dep_no) "직원수" 
	from dept d
	----------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<135> 월별로 [입사월], [인원수]를 검색하면? 
	<조건>입사월 오름차순 유지하십쇼
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		to_char(hire_date, 'MM')||'월'    "입사월"
		,count(*)                         "입사인원수"
	from 
		employee
	group by 
		to_char(hire_date, 'MM')||'월'
	order by  
		"입사월" asc;
	--------------------------------------------------
	<세끼문제>위 문제의 답에서 없는 달은 나오지 않는다. 
		  없는 달도 포함하여, 즉 1~12월까지 다 나오게 하려면?
	--------------------------------------------------
	group by , join 사용
	--------------------------------------------------
	select
		m.month||'월'       "입사월",
		count(e.emp_name)   "입사인원수"
	from 
		(
		   select '01' "MONTH" from dual union
		   select '02' from dual union select '03' from dual union select '04' from dual union select '05' from dual union
		   select '06' from dual union select '07' from dual union select '08' from dual union select '09' from dual union
		   select '10' from dual union select '11' from dual union select '12' from dual
		) m
		,employee e
	where 
		to_char(e.hire_date(+),'MM')=m.month
	group by 
		m.month||'월'
	order by  
		"입사월";
	--------------------------------------------------
	상관쿼리 사용
	--------------------------------------------------
	select
		m.month||'월'                                                               "입사월"
		,(select count(*) from employee e where to_char(e.hire_date,'MM')=m.month ) "입사인원수"
	from 
	(
		select '01' "MONTH" from dual union
		select '02' from dual union select '03' from dual union select '04' from dual union select '05' from dual union
		select '06' from dual union select '07' from dual union select '08' from dual union select '09' from dual union
		select '10' from dual union select '11' from dual union select '12' from dual
	) m
	--------------------------------------------------
	상관쿼리 사용
	--------------------------------------------------
	select
		m.month||'월'                                                               "입사월"
		,(select count(*) from employee e where to_char(e.hire_date,'MM')=m.month ) "입사인원수"
	from 
	(
		select case when rownum<10 then '0' else '' end||rownum "MONTH" from employee where rownum<=12
	) m


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<136> employee 테이블에서 직급순서대로 정렬하여 직급별로 [직급], [직급평균연봉], [인원수]를 검색하면? 
	(높은 직급이 먼저 나와야함. )
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	jikup          "직급"
	,avg(salary)   "직급평균연봉"
	,count(*)      "인원수"
from 
	employee     
group by 
	jikup        
order by
	decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4,' 주임', 5, 6) asc 

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<137> 부서별 [부서번호], [부서명], [직원수], [직원이관리하는고객수]를 검색하면? 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
--------------------------------------------------------
답1
--------------------------------------------------------
	select
		d.dep_no                    "부서번호"
		, d.dep_name                "부서명"
		, count(distinct e.emp_no)  "직원수"
		, count(c.emp_no)           "직원이관리하는고객수"
	from 
		dept d, employee e, customer c
	where 
		d.dep_no=e.dep_no(+) and c.emp_no(+)=e.emp_no
	group by 
		d.dep_no,d.dep_name
	--------------------------------------------------------
	count(distinct e.emp_no) 를 count(e.emp_no)  하면 안됨.
	distinct 안 쓰면 직원수가 중복되서 나온다
	--------------------------------------------------------
	--------------------------------------------------------
	count(c.emp_no) 를 count(distinct c.emp_no)  하면 안됨.
	distinct 쓰면 고객을 담당하는 직원수가 된다
	--------------------------------------------------------
--------------------------------------------------------
답2
--------------------------------------------------------
	select
		d.dep_no                                                          as "부서번호"
		, d.dep_name                                                      as "부서명"
		, (select count(*)||'명' from employee e where e.dep_no=d.dep_no) as "부서직원수"
		, (select count(*)||'명' from employee e, customer c where e.dep_no=d.dep_no
				 and e.emp_no=c.emp_no)                           as "담당 고객 수"
	from dept d;
--------------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<138> 퇴직일이 60세 라는 기준 하에  아래 처럼 출력하면?
--------------------------------------------------------------------------------------------------------------------------------
[직원번호], [직원명], [근무년차], [퇴직일까지 남은 년도], [생일(년-월-일 요일명)], [소속부서명], [직속상관명], [직속상관 부서명] 
---------------------------------------------------------------------------------  -------------  -----------  -----------------
                                   employee e1                                       dept  d1     employee e2       dept d2

단 모든 직원 다 나오고, 직급 높은 직원이 먼저 나오고 직급이 같으면 나이가 많은 사람이 나와야함.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select 
	---------------------------------------------------------------------------------------------------------
	e1.emp_no                                                                                "[직원번호]"
	---------------------------------------------------------------------------------------------------------
	, e1.emp_name                                                                            "[직원명]"
	---------------------------------------------------------------------------------------------------------
	, ceil((sysdate-e1.hire_date)/365)                                                       "[근무년차]"
	---------------------------------------------------------------------------------------------------------
	, to_number(to_char(sysdate,'yyyy'))                                                    
	   -to_number((case substr(e1.jumin_num,7,1) 
		when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1   "[나이]"
	---------------------------------------------------------------------------------------------------------
	, 60-(to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1) 
		when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1) "[퇴직년도까지]"
	---------------------------------------------------------------------------------------------------------
	, to_char(to_date(case substr(e1.jumin_num,7,1) 
		when '1' then '19' when '2' then '19' else '20' end
			||substr(e1.jumin_num,1,6),'yyyymmdd'),'yyyy-mm-dd')||' '	
			||to_char(to_date(case substr(e1.jumin_num,7,1) 
				when '1' then '19' when '2' then '19' else '20' end
			||substr(e1.jumin_num,1,6),'yyyymmdd'),'dy','nls_date_language = korean') "[생일]"
	---------------------------------------------------------------------------------------------------------
	, e1.jikup                                                                                "[직급]"
	---------------------------------------------------------------------------------------------------------
	, d1.dep_name                                                                             "[소속부서명]"
	---------------------------------------------------------------------------------------------------------
	, e2.emp_name                                                                             "[직속상관명]"
	---------------------------------------------------------------------------------------------------------
	, d2.dep_name                                                                             "[직속상관소속부서명]"
	---------------------------------------------------------------------------------------------------------
from 
	employee e1, dept d1,employee e2, dept d2
where 
	e1.dep_no  = d1.dep_no(+) and e1.mgr_emp_no = e2.emp_no(+) and e2.dep_no = d2.dep_no(+)
order by 
	decode(e1.jikup ,'사장',1 ,'부장',2 ,'과장',3 ,'대리',4 ,5)
	, case substr(e1.jumin_num,7,1)  when '1' then '19' when '2' then '19' else '20' end ||substr(e1.jumin_num,1,6)
----------------------------------------------------------------------------------------------------------
select 
	e1.emp_no "[직원번호]"
	,e1.emp_name "[직원명]"
	,ceil((sysdate-e1.hire_date)/365)||'년' "[근무년차]"
	,to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1) 
		when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1||'살' "[나이]"
	,60-(to_number(to_char(sysdate,'yyyy'))-to_number((case substr(e1.jumin_num,7,1) 
		when '1' then '19' when '2' then '19'else '20'end)||substr(e1.jumin_num,1,2))+1)||'년' "[남은 퇴직년도]"
	,to_char(to_date(case substr(e1.jumin_num,7,1) 
			when '1' then '19' when '2' then '19'else '20'end
				||substr(e1.jumin_num,1,6),'yyyymmdd'),'yyyy-mm-dd')||' '				
				||to_char(to_date(case substr(e1.jumin_num,7,1) 
						when '1' then '19' when '2' then '19'else '20'end
				||substr(e1.jumin_num,1,6),'yyyymmdd'),'dy','nls_date_language = korean') "생일"
	,e1.jikup	"[직급]"
	,(select d.dep_name from dept d where d.dep_no=e1.dep_no) "[소속부서명]"
	,nvl((select e2.emp_name from employee e2 where e1.mgr_emp_no=e2.emp_no),'없음')   "[직속상관명]"
	,nvl((select d.dep_name from employee e2, dept d 
			where d.dep_no=e2.dep_no and e1.mgr_emp_no=e2.emp_no)||'','없음')	"[직속상관부서명]"
	,(select nvl(count(*), 0) from customer c  where c.emp_no=e1.emp_no) "[담당고객수]"
from employee e1
order by 
	decode(e1.jikup ,'사장',1 ,'부장',2 ,'과장',3 ,'대리',4 ,5)
	, case substr(e1.jumin_num,7,1)  when '1' then '19' when '2' then '19' else '20' end ||substr(e1.jumin_num,1,6)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<139> [인라인뷰(=inline view)] 가 뮙니까? *****
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	from 절에 나오는 select 를 말한다.
	from 절에는 [테이블명]이 나온다. 
	이 자리에 select 나올 경우 select 결과물을 테이블로 생각하면된다.
	인라인뷰는  select 결과물을 테이블로 취급하기 때문에 메모리에 부담을 준다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<140> 연봉 서열대로 직원을 검색하되 1행 부터 10행 까지만 검색하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	****************************************************************
	답1
	****************************************************************
	select
		*
	from
	(
		select 
			rownum RNUM, e.*
		from 
			(select * from employee order by salary desc) e

		where 
			rownum<=10
	)
	where
		RNUM>=1;
	****************************************************************
	답2  => 미안하게도 답1 보다 2~3배 정도 느리다.
	****************************************************************
	select
		*
	from
	(
		select 
			rownum RNUM, e.*
		from 
			(select * from employee order by salary desc) e
	)
	where
		RNUM>=1 and RNUM<=10;
	****************************************************************
	----------------------------------------------------------------
	오라클은 모든 select 결과물에 rownum 컬럼을 붙여준다. 
		이 컬럼안에는 1부터 시작하는 일련번호가 들어가 있다.
	----------------------------------------------------------------
	rownum 컬럼이 where 절에 들어갈 때 주의사항
	----------------------------------------------------------------
		----------------------------------------
		orde by 가 있을 경우 정렬된 후에 rownum 컬럼이 붙는게 아니라
		정렬되기 전에 rownum 컬럼이 붙고 난 후 정렬이 된다.
		그러므로 rownum 컬럼 안의 일련 번호 뒤 엉켜 버린다.
		----------------------------------------
		----------------------------------------
		rownum 자리에 1이 들어가서 false 가 나오는 조건이 있다면 조건이 성립되지 않는다.
		----------------------------------------
		<예> 
			where rownum<=3 (0)  
			where rownum=1 (0)   
			where rownum>=3 (X)  
			where rownum > 1 (X)    
			where rownum = 2 (X)
			where rownum >= 1 and rownum <= 3 (0) 
			where rownum >= 2 and rownum <= 3 (0) 
	----------------------------------------------------------------
	인라인 뷰, 즉 from 절에 나오는 select 는 바깥쪽 select 입장에서는 테이블 처럼 생각한다.
	인라뷰안에 rownum  컬럼이 있다면 바깥쪽 select 입장에서 안쪽 rownum  컬럼은 단순한 일반 컬럼이 된다.
	----------------------------------------------------------------
	<참고문제>이렇게 n행~m행 까지 검색하는 이유는?
	----------------------------------------------------------------
		실제로는 select 의 결과물이 웹브라우저로 출력된다.
		만약  select 결과물이 100,000 행이면 다 보여줄 경우 웹브라우저 로딩이 걸린다.
		그럼므로 1~10행 또는 1행~15행 씩 끊어서 웹브라우저로 출력되야 로딩이 걸리지 않는다.
		이렇게 select 결과물에서 n행 씩 끊어서 화면에 보여주는 것은 [페이징] 처리라고 한다.




	*****************************************************************
	<패턴>n행~m행 까지 검색하는 select 패턴 정리1
	*****************************************************************
	select * from ( select  rownum RNUM, zxcvb.* from  (

		원하는 정렬 select 문

	) zxcvb where  rownum<=마지막행번호 ) where  RNUM>=시작행번호;
	*****************************************************************
	<패턴>n행~m행 까지 검색하는 select 패턴 정리2
	*****************************************************************
	select * from ( select  rownum RNUM, zxcvb.* from  (

		원하는 정렬 select 문

	) zxcvb) where  RNUM>=시작행번호 and RNUM<=마지막행번호;

	*****************************************************************
	<새끼문제>고객 나이 서열중 6행~10행 까지 검색하면?
	*****************************************************************
	select * from ( select  rownum RNUM, zxcvb.* from  (

		select * from customer
		order by
			decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6) asc

	) zxcvb where  rownum<=10 ) where  RNUM>=6;
	*****************************************************************
	<새끼문제>직원 직급 서열중 2행~5행 까지 검색하면?
	*****************************************************************
	select * from ( select  rownum RNUM, zxcvb.* from  (

		select * from employee
		order by
			decode(jikup,'사장',1,'부장',2,'과장',3,'대리',4,'주임',5,'사원',6) asc

	) zxcvb where  rownum<=5 ) where  RNUM>=2;
	----------------------------------------------------------------






■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<139> 오늘부터 10일  이후 까지 날짜 중에 토요일, 일요일, 월요일을 제외한 날의 개수를 구하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<140> 이번달 중에 토요일, 일요일을 제외한 날의 개수를 구하면?  = 이번달 평일 수 구하기
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■





















select
		c.cus_no       "고객번호"
		,c.cus_name      "고객명"
		,nvl(e1.phone,'없음')      "담당직원번호"
		,nvl(e1.emp_name,'없음')      "담당직원명"
		,nvl(d.dep_name,'없음')            "담당직원소속부서명"
		,nvl(s1.sal_grade_no||'','없음')   "담당직원연봉등급"
		,nvl(e2.emp_name,'없음')           "담당직원직속상관명"
		,nvl(e2.jikup,'없음')              "담당직원직속상관직급"
		,nvl(s2.sal_grade_no||'','없음')   "직속상관연봉등급"
		
from
		((((customer c left outer join employee e1 on	c.emp_no = e1.emp_no)
		left outer join employee e2 on e1.mgr_emp_no = e2.emp_no)
		left outer join salary_grade s1 on (e1.salary between s1.min_salary and s1.max_salary))
		left outer join salary_grade s2 on (e2.salary between s2.min_salary and s2.max_salary))
		left outer join dept d on e1.dep_no = d.dep_no 
order by
        c.cus_no

























■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<87> 고객번호, 고객명, 고객담당직원이름 검색?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		c.cus_no          "고객번호"
		,c.cus_name       "고객명"
		,e.emp_name       "고객담당직원이름"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no
	--------------------------------------------
	select
		c.cus_no          "고객번호"
		,c.cus_name       "고객명"
		,e.emp_name       "고객담당직원이름"
	from
		customer c, employee e
	where
		c.emp_no=e.emp_no(+)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<87> 평균 연봉 보다 많이 받는 직원 검색?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select  * from employee where salary>=(select avg(salary) from employee)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<88> 직급별,평균 연봉 검색?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select
		jikup
		,avg(salary)
	from
		employee
	group by
		jikup


















■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<86> 오라클에서 자주 사용되는 숫자함수 예를 보여주세요.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------
	abs(n)
-----------------------------------
		▶ 숫자 n의 절대값을 반환
-----------------------------------
	floor(n)
-----------------------------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 작으면서
			제일 가까운 정수를 반환.
		▶ 좌표계에서 쿵 찍어서 왼쪽 정수값
-----------------------------------
	ceil(n)
-----------------------------------
		▶ 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 크면서
			제일 가까운 정수를 반환.
		▶ 좌표계에서 쿵 찍어서 오른쪽 정수값
-----------------------------------
	round(n,m)
-----------------------------------
		▶ 숫자 n에서 소수 m+1 자리에서 반올림한 수 리턴
-----------------------------------
	trunc(n,m)
-----------------------------------
		▶ 숫자 n에서 소수 m+1 자리부터 버림
-----------------------------------
	sign(n)
-----------------------------------
		▶ n>0 이면 1, n<0 이면 -1, n=0 이면 0을 반환

-----------------------------------
	mod(n,m)
-----------------------------------
		▶ n/m 후 나머지 값을 반환

-----------------------------------
	power(n,m)
-----------------------------------
		▶ n의 m승을 반환



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<60> 오라클에서 자주 사용되는 숫자함수 예를 보여주세요.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

-----------------------------------
	chr(n)
-----------------------------------
		▶ 정수 n을 ascii(아스키) 문자기호로 리턴한다

-----------------------------------
	uppper(s)
-----------------------------------
		▶ 문자열 s를 대문자로 변환시켜 리턴한다

-----------------------------------
	lower(s)
-----------------------------------
		▶ 문자열 s를 소문자로 변환시켜 리턴한다

-----------------------------------
	length(s)
-----------------------------------
		▶ 문자열 s의 길이를 리턴한다

-----------------------------------
	substr(s, n1, n2)
-----------------------------------
		▶ 문자열 s에서 n1번째 자리부터 n2개 까지의 문자를 리턴한다
		▶ n2 생략 시 마지막까지 문자를 리턴한다
		▶ n1이 0일 경우, 1로 바꿔 실행된다
		▶ 자리수는 n>0 경우 왼쪽부터, n1<0 경우 오른쪽부터 셈한다
		-----------------------------------
		select substr( 'You are not alone', 9, 3 ) from dual;
		select substr( 'You are not alone', 0, 5 ) from dual;
		select substr( 'You are not alone', 5) from dual;
		select substr( 'You are not alone', -5, 2 ) from dual;
		select substr( 'You are not alone', 5, 0 ) from dual;
-----------------------------------
	trim(s)
-----------------------------------
		▶ 문자열 s1의 맨 좌구측으 ㅣ공백을 제거하여 리턴한다
			제거 후 또 있으면 계속 제거 후 리턴한다

-----------------------------------
replace( s1, s2, s3 )
-----------------------------------
	▶문자열 s1에서 s2를 s3로 수정해서 리턴한다.
	▶<예> select replace(addr, '서울특별시','서울시')  from employee
	-----------------------------------------------------
	select replace( 'You are not alone', 'You', 'We' ) from dual;
	select replace( 'You are not alone', 'not' ) from dual;
	select translate( 'You are not alone', 'You', 'We' ) from dual;
-----------------------------------
initcap( s )
-----------------------------------
	▶문자열 s에서 각 단어의 첫 문자만 대문자로 변환하고 나머지는
	  모두 소문자로 리턴한다.
	▶select  initcap( 'abc def' ) from dual;
-----------------------------------
lpad( s1, n, s2 )
-----------------------------------
	▶n 자리 만큼 확보하고 s1을 오른쪽 정렬 후 왼쪽에 생긴 빈 공백에
	  문자열 s2를 채워 리턴한다.
	▶select lpad( 'abc', 7, ' ' ) from dual;
-----------------------------------
rpad( s1, n, s2 )
-----------------------------------
	▶n 자리 만큼 확보하고 s1을 왼쪽 정렬 후 오른쪽에 생긴 빈 공백에
	  문자열 s2를 채워 리턴한다.
	▶select rpad( 'abc', 7, '#' ) from dual;
-----------------------------------
instr( s1, s2, n1, n2 )
-----------------------------------
	▶( s1:타겟문자, s2:찾을문자, 에서 n1:검색시작위치, n2:몇번째 )
	<주의>오라클에서 위치를 따질 때 시작은 0이 아니라 1이다.
	▶문자열 s1 에서 문자열 s2 가 있는 위치 반환. (자바의 indexof(~) 와 비슷한 기능)
	select
		instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la' ),
		instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1),
		instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 1, 2),
		instr( 'Every Sha-la-la-la Every wo-o-wo-o', 'la', 12, 2)
	from dual;


	select * from employee where emp_name like '%김%'
	select * from employee where instr(emp_name, '김')>0;
	------------------------------------------------------------
	select * from employee where instr(emp_name, '김')=1;
	select * from employee where emp_name like '김%'













































